# `hyperledger fabric` 读写集

本文档讨论了有关读写集语义的当前实现的详细信息。

# 交易模拟和读写集

在参与者**模拟交易期间**，为交易准备了**读写集**。**读集包含交易在模拟期间读取的*唯一键*及其*提交版本*的列表**。**写集**包含**唯一键的列表**（尽管可能**与读集中存在的键重叠**）以及交易写入的新值。如果**交易执行的更新是删除键**，则为键设置**删除标记**（代替新值）。

此外，如果**交易为键多次写入值**，则仅**保留最后写入的值**。此外，如果交易读取键的值，则即使**交易在发出读取之前更新了键的值**，也**会返回已提交状态的值**。换句话说，不支持`Read-your-writes`语义。

如前所述，**键的版本仅记录在读取集**中，**写集只包含交易设置的唯一键列表及其最新值**。

可以有各种方案来实现版本。**版本控制方案的最低要求是为给定键生成非重复标识符**。例如，对于版本使用**单调递增**的数字可以是一种这样的方案。在当前实现中，使用基于**区块链高度**的版本控制方案，其中提交**交易的高度**被用作交易**修改的所有键的最新版本**。在此方案中，**交易的高度由元组表示**（`txNumber`是块内交易的高度）。与增量数字方案相比，该方案具有许多优点。主要是，**它可以实现其他组件**，如陈述，**交易模拟和验证**，以进行**有效的设计选择**。

以下是通过**模拟假设交易**准备的示例读写集的图示。为简单起见，在插图中，使用**增量数来表示版本**。

```xml
<TxReadWriteSet>
  <NsReadWriteSet name="chaincode1">
    <read-set>
      <read key="K1", version="1">
      <read key="K2", version="1">
    </read-set>
    <write-set>
      <write key="K1", value="V1"
      <write key="K3", value="V2"
      <write key="K4", isDelete="true"
    </write-set>
  </NsReadWriteSet>
<TxReadWriteSet>
```

此外，如果交易在**模拟期间执行范围查询**，则**范围查询及其结果将作为`query-info`添加到读写集**。

# 使用读写集进行交易验证和更新世界状态

**提交者**使用读写集的**读集部分**来**检查交易的有效性**和**读写集的写集部分**，以**更新受影响的键的版本和值**。

在**验证阶段**，如果**交易的读取集中存在的每个键的版本与世界状态**中**相同键的版本匹配，则认为交易有效**。假设**所有前面的有效交易**（包括同一块中的前面的交易）已提交（已提交状态）。如果**读写集还包含一个或多个查询信息，则执行附加验证**。

该附加验证应该确保在查询信息中**捕获的结果的超范围**（即**范围的并集**）中**没有插入/删除/更新键**。换句话说，如果在**提交状态的验证期间**重新执行任何**范围查询**（在模拟期间执行的交易），它**应该产生与模拟时交易所观察**到的**结果相同**的结果。此**检查确保**如果交易在**提交期间**观察**幻像项**，则应将**交易标记为无效**。注意，该**幻像保护仅限于范围查询**（即，链码中的`GetStateByRange`函数），并且**尚未针对其他查询**（即，链码中的`GetQueryResult`函数）实现。其他**查询存在幻像风险**，因此**应仅用于未提交排序的只读交易**，除非应用程序**可以保证模拟和验证/提交时间之间结果集的稳定性**。

如果交易通过了**有效性检查**，则提交者使用**写集来更新世界状态**。在更新阶段，对于**写集**中存在的每个键，**相同键的世界状态中的值被设置为写集中指定的值**。此外，**世界状态中的键版本**被更改以反映**最新版本**。

# 模拟和验证示例

本节通过示例场景帮助理解语义。出于该示例的目的，**世界状态中的键`k`的存在由元组`(k,ver,val)`表示**，其中`ver`是以`val`为其值的键`k`的**最新版本**。

现在，考虑一组五个交易`T1，T2，T3，T4和T5`，**所有交易**都在世界状态的**同一快照上进行模拟**。以下代码段显示了**模拟交易的世界状态的快照**，以及每个交易执行的**读写活动的顺序**。

```sh
World state: (k1,1,v1), (k2,1,v2), (k3,1,v3), (k4,1,v4), (k5,1,v5)
T1 -> Write(k1, v1'), Write(k2, v2')
T2 -> Read(k1), Write(k3, v3')
T3 -> Write(k2, v2'')
T4 -> Write(k2, v2'''), read(k2)
T5 -> Write(k6, v6'), read(k5)
```

现在，假设这些交易按`T1，...，T5`的顺序排序（可以包含在单个块或不同的块中）

1. `T1`**通过**验证，因为它**不执行任何读取**。此外，世界状态中的键`k1`和`k2`的元组被更新为`（k1,2，v1'）`，`（k2,2，v2'）`
2. `T2`**未通过**验证，因为它**读取了一个键`k1`**，该键由**前一个交易`T1`修改**
3. `T3`**通过**验证，因为它**不执行读取**。此外，世界状态中键`k2`的元组更新为`（k2,3，v2''）`
4. `T4`**未通过**验证，因为它**读取**了一个键`k2`，该键由前面的交易`T1`**修改**
5. `T5`**通过**验证，因为它**读取**了一个键`k5`，该键**未被**任何前面的交易**修改**

> **注意**：尚不支持具有多个读写集的交易。


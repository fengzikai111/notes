# `hyperledger fabric` 交易流程

本文档概述了**标准资产交换过程中发生的交易机制**。该方案包括两个客户A和B，他们正在买卖萝卜。他们每个人都有一个网络上的同伴，**通过他们发送交易并与分类账进行交互**。

![_images/step0.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/step0.png)

## 假设

此流程假定**已建立并运行通道**。应用程序用户**已注册并认证了组织的证书颁发机构(CA)**，并收到了**必要的加密材料**，该材料用于向**网络进行身份验证**。

链码(包含表示萝卜市场**初始状态的一组键值对**)安装在**对等体上并在通道上实例化**。链码包含定义**一组交易指令**的**逻辑**和萝卜的商定**价格**。还为此链码设置了一个**认可策略**，声明`peerA`和`peerB`都必须**支持任何交易**。

![_images/step1.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/step1.png)

## 1、客户A启动交易

发生了什么？ **客户`A`正在发送购买萝卜的请求**。该请求的**目标是`peerA`和`peerB`**，它们分别代表**客户端A和客户端B**。认可策略**规定两个对等端**必须**支持任何事务**，因此**请求将转发给`peerA`和`peerB`**。

接下来，**构建交易提议**。利用受支持的`SDK`(`Node，Java，Python`)的**应用**程序，利用一个**可用的`API`**来生成**交易提议**。该提议是**调用链码功能的请求**，以便可以将**数据读取或写入分类帐**(即为资产写入新的键值对)。`SDK`用作`shim`程序，将**事务提议打包为正确的架构格式**(`gRPC`上的协议缓冲区)，并**使用用户的加密凭据**为此事务提议**生成唯一签名**。

![_images/step2.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/step2.png)

## 2、支持对等方验证签名并执行事务

认可对等方验证(1)**交易提案格式正确**，(2)**过去未提交过**(重放攻击保护)，(3)**签名有效**(使用`MSP`)，以及(4)**提交者**(在示例中为客户端`A`)被**正确授权在该通道上执行建议的操作**(即，每个支持对等体确保提交者满足通道的**写入者策略**)。支持对等体将**事务提议输入作为调用的链码函数的参数**。然后针对**当前状态数据库**执行链码以**产生包括响应值**，**读取集和写集的事务结果**。此时没有对**分类帐进行更新**。这些值的集合以及**支持对等方**的签名将作为“**提议响应**”传递回`SDK`，该`SDK`解析应用程序要使用的有效负载。

> **注意**：`MSP`是一个对等组件，允许**对等方验证从客户端到达的交易请求并签署交易结果**(认可)。写入策略在通道创建时定义，并确定**哪些用户有权向该通道提交事务**。

![_images/step3.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/step3.png)

## 3、检查提案回复

应用程序**验证支持对等签名**并**比较提议响应**以确定**提议响应是否相同**。如果链码**仅查询**分类帐，则应用程序**将检查查询响应**，并且通常**不会将事务提交给定序服务**。如果客户端**应用程序**打算将**事务提交给定序服务**以**更新分类帐**，则应用程序在**提交之前**确定**是否已满足指定的认可策略**(即，`peerA`和`peerB`都认可)。该体系结构使得即使**应用程序**选择**不检查响应**或以**其他方式转发*未经许可*的事务**，该**认可策略仍将由对等体*强制执行*并在提交验证阶段维持**。

![_images/step4.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/step4.png)

## 4、客户组装背书认可到交易

该应用程序将“**交易提议**”中的交易和**响应“广播”到定序服务**。该事务将**包含读/写集**，签名**对等签名和通道ID**。定序服务**不需要检查交易**的整个内容以**执行其操作**，它只是从**网络中的所有通道接收交易**，**按时间顺序**按**通道**对它们进行**排序**，并**创建每个通道的交易块**。

![_images/step5.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/step5.png)

## 5、交易已验证和提交

**交易块被“交付”到通道上的所有对等方**。 **验证**块内的**事务**以**确保满足认可策略**并**确保读集变量的分类帐状态没有变化**，因为**读集是由事务执行生成**的。 块中的事务被**标记为有效或无效**。

![_images/step6.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/step6.png)

## 6、更新分类账

**每个对等体将块附加到通道的链**，并且对于**每个有效的事务**，**写集被提交到当前状态数据库**。 **发出**一个事件，**通知**客户端应用程序事务(调用)**已被不可变地附加到链中**，以及**通知该事务是否已经过验证或无效**。

注意：请参阅[序列图](https://hyperledger-fabric.readthedocs.io/en/latest/arch-deep-dive.html#swimlane)以更好地了解事务流。


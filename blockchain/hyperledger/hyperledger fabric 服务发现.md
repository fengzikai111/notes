# `hyperledger fabric` 服务发现

为了在对等体上**执行链代码**，向交易者提交交易，并且要更新有关**交易状态**的更新，应用程序连接到`SDK`公开的`API`。

但是，**`SDK`需要大量信息**才能允许应用程序连接到相关的**网络节点**。除了通道上的**订货人和同行的`CA`和`TLS`证书**，以及他们的**`IP`地址和端口号**，它**必须知道相关的认可政策以及哪些同行安装了链码**（因此应用程序知道哪些同行发送链码提案）。

在`v1.2`之前，此**信息是静态编码**的。但是，此实现**不会对网络更改动态响应**（例如**添加已安装**相关链代码的对等方，或**临时脱机**的对等方）。静态配置也**不允许应用程序对签名策略本身的更改做出反应**（当新组织**加入**渠道时可能会发生）。

此外，**客户端应用程序无法知道**哪些对等方更新了分类帐，哪些不知道。因此，应用程序可能会向其分类帐数据与网络其余部分**不同步的对等方提交提案**，从而导致事务在提交时**失效并因此浪费资源**。

发现服务通过让**对等方动态计算所需信息**并以可消费方式将其呈现给`SDK`来**改进**此过程。

# 服务发现如何在`Fabric`中工作

知道应用程序开发人员/管理员信任的一组**对等方**以**提供对发现查询**的真实响应，从而**引导**应用程序。客户端应用程序使用的一个好的**候选对等体**是**同一组织**中的候选对等体。

应用程序**向发现服务发出配置查询**，并获**取与网络的其余节点**通信所需的**所有静态信息**。通过**向对等方**的发现服务发送**后续查询**，可以在**任何时候刷新该信息**。

该**服务在对等体上运行**，而**不是在应用程序上**，并使用**由`gossip`通信层**维护的网络元数据信息来**找出哪些对等体在线**。它还**从对等方的状态数据库中提取信息**，例如任何相关的**认可策略**。

通过服务发现，**应用程序不再需要指定他们需要认可的对等方**。`SDK`可以简单地向**发现服务发送查询**，**询问给定频道和链代码`ID`**需要哪些**对等体**。然后，发现服务将计算由两个对象组成的描述符：

1. **布局编排设计 `Layout`**：应该选择的每个组的**对等组列表**和相应数量的**对等体**。
2. **组对等映射**：从布局中的**组**到**通道的对等方**。在实践中，每个组很可能是**代表单个组织的同行**，但由于服务`API`是**通用**的而且**对组织一无所知**，因此这只是一个“组”。

以下是评估`AND（Org1，Org2）`策略的描述符的示例，其中每个组织中有两个对等体。

```go
Layouts: [
     QuantitiesByGroup: {
       “Org1”: 1,
       “Org2”: 1,
     }
],
EndorsersByGroups: {
  “Org1”: [peer0.org1, peer1.org1],
  “Org2”: [peer0.org2, peer1.org2]
}
```

换句话说，**认可策略**需要来自**`Org1`中的一个对等体**和**`Org2`中的一个对等体**的签名。它提供了那些可以认可的组织中**可用对等体的名称**（`Org1`和`Org2`中的`peer0`和`peer1`）。

然后`SDK`从列表中**选择随机布局**。在上面的示例中，**认可政策是`Org1 AND Org2`**。如果它是一个`OR`策略，`SDK`将**随机选择`Org1`或`Org2`**，因为来自`Org`的对等体的签名将满足该策略。

`SDK`选择了布局后，它会根据**客户端指定的条件**从**布局中的对等体中进行选择**（`SDK`可以执行此操作，因为它可以访问元数据，如分类帐高度）。例如，根据布局中每个组的**对等方数量**，它可以更喜欢具有**更高分类账高度**的对等方或者**排除应用程序发现离线**的对等方。如果**根据条件**不优选单个对等体，则`SDK`将从**最符合标准的对等体中随机选择**。
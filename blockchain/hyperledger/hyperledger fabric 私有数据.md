# `hyperledger fabric` 私有数据

> **注意**：本文件假定已了解有[关私有数据](https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html)的文档中的概念。

# 私有数据收集定义

**集合定义包含一个或多个集合**，每个**集合都有一个策略定义**，列出集合中的组织，以及用于在**批准时控制私有数据传播**的属性，以及可选的**是否清除数据**。

在链代码**实例化（或升级）时**，集合定义被**部署到通道**。如果使用**对等`CLI`实例化**链代码，则使用`--collections-config`标志**将集合定义文件传递给链代码实例化**。如果使用客户端`SDK`，请查看[`SDK`文档](https://fabric-sdk-node.github.io/)以获取有关提供集合定义的信息。

**集合定义由五个属性组成**：

+ `name`：集合的名称。
+ `policy`：**私有数据收集分发策略**定义允许哪些组织的**对等体持久保存**使用**签名策略语法**表示的收集数据，每个成员都**包含在`OR`签名策略列表**中。为了支持**读/写**事务，**私有数据分发策略必须定义比链代码认可策略更广泛的组织集合**，因为对等体**必须具有私有数据才能支持提议的事务**。例如，在一个拥有十个组织的渠道中，五个组织可能被纳入私人数据收集分配政策，但认可政策可能要求任何三个组织认可。
+ `requiredPeerCount`：每个支持对等方**必须在对等方签署认可之前**成功**传播私有数据**并将**提案响应返回给客户端的最小对等方**（跨授权组织）。要求传播作为**认可的条件**将确保即使认可对等方不可用，也可以在网络中获得私有数据。当`requiredPeerCount`为`0`时，表示**不需要分发**，但如果`maxPeerCount`大于零，则可能**存在一些分布**。通常**不建议使用`requiredPeerCount`**，因为如果**支持对等方变得不可用**，它**可能导致网络中的私有数据丢失**。通常，希望在**认可时间至少要求私有数据的一些分发**，以**确保网络中多个对等方上的私有数据的冗余**。
+ `maxPeerCount`：出于数据**冗余目的**，每个支持对等方**将尝试将私有数据分发到的其他对等方**（跨授权组织）的最大数量。如果认可对等体在**认可时间和提交时间**之间变得**不可用**，则作为集合成员但**在认可时间尚未接收私有数据**的其他对等体将能够从**私有数据被传播到的对等体中提取私有数据**。如果此值**设置为`0`，则不会在认可时传播私有数据**，从而**迫使**私有数据在**提交时阻止所有授权对等方**上的对等方。
+ `blockToLive`：表示数据在**块方面应在私有数据库上存在多长时间**。数据将在私有数据库上为此**指定数量的块生效，之后将被清除**，从而使这些数据从网络中**过时**。要**无限期**地保留私有数据，即**永远不会清除**私有数据，请**将`blockToLive`属性设置为`0`**。

这是一个示例集合定义`JSON`文件，包含两个集合定义的数组：

```json
[
 {
    "name": "collectionMarbles",
    "policy": "OR('Org1MSP.member', 'Org2MSP.member')",
    "requiredPeerCount": 0,
    "maxPeerCount": 3,
    "blockToLive":1000000
 },
 {
    "name": "collectionMarblePrivateDetails",
    "policy": "OR('Org1MSP.member')",
    "requiredPeerCount": 0,
    "maxPeerCount": 3,
    "blockToLive":3
 }
]
```

此示例使用`BYFN`示例网络中的组织`Org1`和`Org2`。`collectionMarbles`定义中的**策略授权组织使用私有数据**。当链代码数据需要从**订购服务节点保持私有**时，这是典型配置。但是，`collectionMarblePrivateDetails`定义中的**策略限制对通道中组织子集的访问**（在本例中为`Org1`）。在实际情况中，**渠道中将有许多组织**，每个集合中有两个或更多组织在它们之间**共享私有数据**。

## 背书

由于私有数据**未包含在提交给订购服务的交易中**，因此**未包含在分配给渠道中所有对等方的块中**，**认可同行**在**向授权组织**的**其他同行传播私人数据**方面发挥着重要作用。这确保了**通道集合中私有数据**的**可用性**，即使在**支持对等体**在其**认可后变得不可用时**也是如此。为了帮助进行这种传播，集合定义中的`maxPeerCount`和`requiredPeerCount`属性**控制着认可时间的传播程度**。

如果支持对等方**无法成功**地将私有数据**传播到至少`requiredPeerCount`**，则它将**向客户端返回错误**。**认可对等体将尝试将私有数据传播给不同组织的对等体**，以**确保每个授权组织具有私有数据的副本**。由于**事务未在链代码执行时提交**，因此**支持对等方和接收方对等方**将**私有数据的副本与区块链一起存储在本地临时存储**中，**直到提交事务为止**。

## 私有数据的提交方式

当**授权对等方在提交时**在其**临时数据存储中**没有**私有数据的副本**时（因为它们**不是认可对等方**，或者因为**它们在认可时间没有通过传播接收私有数据**），它们将**尝试提取来自另一个授权对等方的私有数据**，基于对等配置`core.yaml`文件中的**对等属性`peer.gossip.pvtData.pullRetryThreshold`**，可配置的时间量。

> **注意**：如果请求对等方是**私有数据传播策略所定义的集合的成员**，则被要求**提供私有数据的对等方**将**仅返回私有数据**。

**使用`pullRetryThreshold`时的注意事项**：

+ 如果请求对等方能够检索`pullRetryThreshold`内的**私有数据**，它将**事务提交到其分类帐**（包括私有数据**散列**），并将**私有数据存储在其状态数据库中**，逻辑上与**其他通道状态数据分开**。
+ 如果请求对等方**无法检索`pullRetryThreshold`内的私有数据**，则它会将事务**提交给它的区块链**（包括私有数据**哈希**），而**不包含私有数据**。
+ 如果对等方**有权访问私有数据**但**缺少私有数据**，那么该对等方将**无法支持将来引用丢失的私有数据的事务**，将**检测到丢失的键的链代码查询**（状态数据库中**键哈希的存在**），链代码将收到错误。

因此，**必须将`requiredPeerCount`和`maxPeerCount`属性设置得足够大**，以**确保通道中私有数据的可用性**。例如，如果**每个签署对等方**在事务**提交之前**变得**不可用**，则`requiredPeerCount`和`maxPeerCount`属性**将确保私有数据在其他对等方上可用**。

> **注意**：要使集合起作用，**必须正确配置跨组织的`gossip`**。请参阅[关于`Gossip`数据传播协议](https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html)的文档，**特别注意“锚点对等”部分**。

# 从链代码引用集合

一组`shim`程序`API`可用于设置和检索私有数据。

相同的链代码数据操作可以应用于**通道状态数据和私有数据**，但在**私有数据的情况下**，**集合名称与链代码`API`中的数据一起指定**，例如`PutPrivateData(collection,key,value)`和`GetPrivateData(collection,key)`。

**单个链代码可以引用多个集合**。

## 如何在链代码提议中传递私人数据

由于**链码提议存储在区块链中**，因此**不要在链码提议的主要部分中**包含**私有数据**也很重要。链代码提议中称为**瞬态字段**的特殊字段**可用于将来自客户端的私有数据**（或链代码将用于**生成私有数据**的数据）**传递给对等端上的链代码调用**。链代码可以通过**调用`GetTransient() API`来检索瞬态字段**。此**瞬态字段将从通道事务中排除**。

# 使用私有数据时的注意事项

**查询私人数据**：

使用`shim`程序`API`可以**像普通渠道数据一样查询私有集合**数据：

+ `GetPrivateDataByRange(collection, startKey, endKey string)`
+ `GetPrivateDataByPartialCompositeKey(collection, objectType string, keys []string)`

对于`CouchDB`状态数据库，可以使用`shim API`传递`JSON`内容查询：

- `GetPrivateDataQueryResult(collection, query string)`

**限制**：

+ 调用执行范围或丰富`JSON`查询的`chaincode`的客户端应该知道，如果他们查询的**对等方缺少私有数据**，他们**可能会收到结果集的子集**，具体取决于上面的“**私有数据传播**”部分中的说明。客户端可以**查询多个对等体**并**比较结果**以确定对等体**是否可能缺少某些结果集**。
+ **不支持在单个事务中**执行范围或丰富的`JSON`**查询和更新**数据的`Chaincode`，因为**无法在无法访问**私有数据的**对等方上**或在**缺少私有数据的对等方**上**验证查询结果是否可以访问**。如果链代码**调用同时查询和更新私有数据，则提议请求将返回错误**。如果您的应用程序**可以容忍链代码执行和验证/提交时间之间的结果集更改**，那么您**可以调用一个链代码函数来执行查询**，然后**调用第二个链代码函数来进行更新**。请注意，调用`GetPrivateData()`以**检索单个键**可以在与`PutPrivateData()`调用**相同的事务中进行**，因为所有对等体都可以**根据散列键版本验证键读取**。
+ 请注意，**私有数据集合**仅定义哪个组织的**对等方有权接收和存储私有数据**，从而暗示哪些**对等方可用于查询私有数据**。私有数据集合本身**不限制链代码中的访问控制**。例如，如果**非授权客户端能够在有权访问私有数据**的对等端上调用链代码，则链代码逻辑仍然需要像往常一样**强制执行访问控制**，例如通过调用`GetCreator()`链代码`API`或使用客户端身份链码库。

# 将索引与集合一起使用

`CouchDB`作为状态数据库主题描述了可以应用于**通道状态数据库以启用`JSON`内容查询的索引**，方法是在链代码**安装时将索引打包在`META-INF/statedb/couchdb/indexes`目录中**。同样，索引也可以通过在`META-INF/statedb/couchdb/collections/<collection_name>/indexes`目录中**打包索引来应用于私有数据集合**。[这里有一个示例索引](https://github.com/hyperledger/fabric-samples/blob/master/chaincode/marbles02_private/go/META-INF/statedb/couchdb/collections/collectionMarbles/indexes/indexOwner.json)。

## 私人数据清除


# Hyperledger fabric 关键概念



# 介绍

Hyperledger Fabric 是一个分布式账本的区块链方案解决平台，采用模块化、提供高度机密、弹性灵活和可扩展的架构。它旨在支持不同组件模块的可插拔实现，并适应经济生态系统中复杂性。

## 什么是区块链？

区块链有三部分重要组成，它们分别是分布式分类账本、智能合约、共识机制。

### 分布式分类账本

区块链网络的核心是一个分布式的分类账本，记录区块链网络上发生的所有交易信息。

分布式分类账本是分散的，它们被复制到区块链网络中的不同节点上，每个参与者都维护其中的程序进行**协作**。所以分布式分类账本是分散和合作的强大，反映了企业在现实世界中交换商品和服务的方式。

![_images / basic_network.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/basic_network.png)

除了分散和协作的技术特点外，记录到区块链的信息数据还使用**加密**技术，保证数据一旦上链后将**无法修改**。这种**不可变**的特性让定位数据的**出处**变得简单。因为参与者可以确定数据信息在事后没有改变。这就是为什么区块链有时被描述为**证明系统的原因**。

### 智能合约

为了支持信息的一致更新特性，并启用分类账本的功能（交易、查询），区块链网络使用**智能合约**来提供对分类账本的受控访问。

![_images / Smart_Contract.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/Smart_Contract.png)

智能合约不仅是封装信息并在整个区块链网络中保持简单的关键机制。还可以编写参与者自动执行某些交易。例如：可以编写智能合约规定运输物品的成本，其中运费根据运输中的速度而变化，根据双方同意并写入分类账的条款。当收到物品时，适当的资金可以转手。

### 共识机制

共识是保持分类账本交易在整个区块链网络中同步的过程。确保分类账本仅仅在交易时被相应的参与者批准并执行更新，在当分类账本更新时，它们要以相同的顺序执行相同的交易数据更新，这系列动作被称为**共识**。

![_images / consensus.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/consensus.png)

区块链视为共享的复制交易系统就足够了，该系统通过智能合约进行更新，并通过称为共识的协作流程保持一致。

## 为什么区块链有用？

### **今天的记录系统** 

今天的交易网络都是自商业记录以来一直存在微小更新记录的网络版本。业务网络的成员彼此进行交易，他们各自维护自己的交易记录。

![_images / current_network.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/current_network.png)

现代技术已经从石碑布匹、纸质记录到硬盘或云存储演进，但所有系统底层结构都是相同的。由于所有参与者的身份不一致，要建立一个统一的系统是不可能。所有的合同是手动签署和执行，每个数据库都存储交易的唯一信息。即使可见性和信任的需求很明显，今天的信息和流程共享方法也不可能构建一个跨越业务网络的记录系统

### **区块链差异** 

由于现代的交易系统效率低下，而是在网络上建立身份、执行交易、存储数据。要想让数据一旦写入、无法修改，这时候就需要区块链网络。

![_images / future_net.png](https://hyperledger-fabric.readthedocs.io/en/latest/_images/future_net.png)

这是一个区块链网络，每个参与者都有一个分类账本的副本。除了共享分类账本 信息之外，还共享更新分类账本的过程。与现代系统不同，参与者的私人程序用于更新私人的分类账本，区块链系统具有共享分类账本和更新分类账本的特性。

通过共享分类账本协调业务网络能力，区块链网络可以减少与私人信息和处理的相关时间、成本和风险，同时提高信任和可见性。

### 什么是`Hyperledger Fabric`？

Linux基金会于2015年创建了`Hyperledger`项目，以推进跨行业的区块链技术。它不是宣布单一区块链标准，而是鼓励通过社区流程开发区块链技术的协作方法，其中包括鼓励开放式开发和随着时间的推移采用关键标准的知识产权。

`Hyperledger Fabric`是`Hyperledger`中的区块链项目之一。与其他区块链技术一样，它有一个分类账，使用智能合约，是参与者管理交易的系统。

`Hyperledger Fabric`从其他区块链系统中打破的地方是**私有**和**许可**。`Hyperledger Fabric`网络的成员通过可信赖的**会员服务提供商（MSP）**注册，而不是允许未知身份参与网络的开放式无权限系统（需要诸如“工作证明”之类的协议来验证交易并保护网络）。

`Hyperledger Fabric`还提供多种可插拔选项。分类帐数据可以以多种格式存储，共识机制可以交换进出，并且支持不同的`MSP`。

`Hyperledger Fabric`还提供创建**通道的功能**，允许一组参与者创建单独的交易分类帐。对于网络而言，这是一个特别重要的选择，其中一些参与者可能是竞争对手，并且不希望他们做出的每笔交易 - 例如，他们向某些参与者提供的特殊价格，而不是每个参与者都知道的其他参与者。如果两个参与者组成一个通道，那么这些参与者，而不是其他参与者拥有该通道的分类帐副本。

**共享分类帐** 

`Hyperledger Fabric`有一个分类账本子系统，它包括两个组件：**世界状态**和**交易日志**。每个参与者都拥有他们所属的`Hyperledger Fabric`网络中分类账本的一个副本。

世界状态描述了在给定时间点下的分类账本的状态，它是分类账本的数据库。交易日志组件记录当前分类账本的所有交易，它是世界状态的更新历史。然后，**分类账本是世界状态数据库和交易日志历史记录的组合**。

分类账本具有可以替换的状态数据库。默认情况下，是`LevelDB`键值存储数据库。交易日志不需要是可插入的，它只记录区块链网络中分类账本交易时数据库的前后值。

**智能合约**

`Hyperledger Fabric`智能合约以**链代码**编写，当该应用程序需要与分类帐交互时，由**区块**链外部的应用程序调用。在大多数情况下，`chaincode`只与分类帐的数据库组件，世界状态（例如，查询它）交互，而不与交易日志交互。

`Chaincode`可以用几种编程语言实现。目前，支持`Go`和`Node`、`Java`。

**隐私**

根据企业需求，在区块链网络中参与者对自己共享的信息可能非常的敏感。

`Hyperledger Fabric`支持隐私，可以使用通道方式来保护敏感数据。它是关键操作要求是相对开放的网络。

**共识**

交易必须按照发生的顺序写入分类账本，即使他们位于网络中不同的参与者之间。为此，必须建立交易的顺序，并且采用一种方法来拒绝错误（或恶意）的交易数据插入到分类账本中。

`Hyperledger Fabric`旨在允许网络启动者选择最能代表参与者之间存在的关系的共识机制。与隐私一样，有一系列需求；从在他们的关系中高度结构化的网络到更加点对点的网络。

我们将了解有关`Hyperledger Fabric`共识机制的更多信息，目前包括`SOLO`和`Kafka`。

# `Hyperledger Fabric` 功能

`Hyperledger Fabric` 是分布式账本技术（`DLT`）的一种实现，可在模块化架构区块链架构中提供企业级网络安全性，具有可扩展、机密性、高性能的特点。



## 身份管理

为了启用权限网络，`Hyperledger Fabric` 提供了一个**成员身份服务**功能，用于管理用户ID并对网络上的所有参与者进行**身份验证**。访问控制列表可用于通过授权特定网络操作来提供额外的权限控制层。例如，可以允许特定用户ID调用链代码应用程序，但是不能部署新的链代码。

## 隐私和保密

`Hyperledger Fabric` 使竞争的商业利益以及任何需要私密交易的群体能够在同一个权限网络上共存。专用的**通道**是受限的信息传递的路径，可以用于网络成员的特定子集提供**交易隐私和保密性**。通道上的所有数据（交易、成员、通道）都是**不可见**的，对于没有明确授权给通道的访问权限的任何网络成员都是不可访问的。

## 高效性能

`Hyperledger Fabric` 按节点类型分配**网络角色**，为了向网络提供**并发性和并行性**，**执行交易和交易排序、交易提交**是分开的。在排序交易之前执行交易能够使**每个对等节点同时处理多个交易**。这种并发执行提高了每个对等体的处理效率，并且**加速了向排序服务提供交易交付**速度。

除了并行处理之外，**分工**还可以减轻排序节点对交易执行和分类账本**维护的需求**，同时使对等节点**免于排序**（共识）服务的工作负载。角色的分配也**限制了授权和认证**的所需处理，所有对等节点都不必信任任何排序节点，反之亦然。因此一方上的进程可以独立于另一方的验证运行。

## `Chaincode`功能

`Chaincode` 应用程序编码由通道上特定类型的交易调用的逻辑。例如：变更资产所有权变更参数的 `Chaincode` 可确保所有转让所有权的交易都遵循相同的规则和要求。**系统链码**被区分为链码，其定义整个通道的操作参数；生命周期和配置系统链码定义了通道规则；认可和验证系统 `Chaincode` 定义了认可和验证交易的要求。

## 模块化设计

`Hyperledger Fabric` 实现了模块化架构，为网络设计人员提供了功能选择。例如：用于身份、排序（一致性）、加密的特定算法可以插入任何`Hyperledger Fabric`网络。结果是任何行业或公共领域都可以采用的通用区块链架构，并确保其网络可跨市场，监管和地理边界进行互操作。

# `Hyperledger Fabric` 模型

`Hyperledger Fabric` 的关键设计特性，实现了全面可定制的企业区块链解决方案的承诺：

+ **资产**：可以通过网络交换几乎任何具有货币价值的东西，从整个食品到古董、期货。
+ `Chaincode` ：Chaincode的执行和交易排序共识分开，限制了跨节点类型所需的信任和验证级别，并优化了网络可扩展性和性能。
+ **分类账功能**：不可变的共享分类账本为每个通道编码整个交易历史记录，并包括类似的`SQL`查询功能，以便进行有效的审计和解决争议。
+ **隐私**：通道和私人数据的收集实习了私密和加密的多边交易，这些交易通常是共同网上交换的资产的竞争企业和受监管行业所需求的。
+ **安全和会员服务**：允许会员资格提供可信任的区块链网络，参与者知道所有的交易都可以由授权的监管机构和审计员检测和跟踪。
+ **共识**：达成共识的可实现企业所需的灵活性和可扩展性。

## 资产

资产可以从有形（房地产和硬件）到无形资产（合同和知识产权）。`Hyperledger Fabric`提供链码交易修改资产的功能。

资产在`Hyperledger Fabric`中表示为**键值对的集合**，更改状态记录为通道分类账本上的交易。**资产可以用二进制或`JSON`格式表示**。

## `Chaincode`

`Chaincode` 是定义资产或资产的软件，以及修改资产的交易指令。可以将`Chaincode` 理解为业务逻辑。`Chaincode` 强制读取或更改键值对或其他状态数据库信息规则。`Chaincode` 函数针对当前分类账本的状态数据库执行，并通过交易提议启动执行。`Chaincode` 执行导致一组键值写入，可以提交给网络并应用于所有对等方的分类账。

## 分类账功能

分类账本是结构中**所有状态转换的顺序防篡改记录**。状态转换是参与方进行**提交链码调用（交易）**的结果。每个交易都会**生成一组资产键值对**，这些键值对作为创建、更新或删除提交到分类账本中。

分类账本由区块链上的**链**组成，用于**以块的形式存储不可变的顺序记录**。以及用于**维护当前结构状态的状态数据库**。**每个通道都有一个分类账本**，每个对等节点为所属的每个通道维护一个**分类账本的副本**。

**分类账本具有以下功能：**

+ 使用基于**秘钥的查找**，利用**范围查询**和**组合秘钥查询**来查询和更新分类账本
+ 使用丰富的查询语言作为**只读查询**（如果使用`CouchDB`作为状态数据库）
+ 只读历史记录查询，查询秘钥的分类账本历史记录，启用数据源方案
+ **交易包含**每个认可对等节点的**签名**，并**提交给排序**服务
+ 交易按顺序**进行排列**，并从排序服务**交付**到通道上的**对等对等**节点
+ 对等节点根据**认可策略验证交易并执行**认可策略
+ 在创建区块之前，执行**版本控制检查**，以明确确保自链码执行时间以来读取的**资产状态未发生更改**
+ 一旦交易**被验证并提交**，就存在**不变性**
+ 通道的分类账包含定义**策略、控制访问列表**和其他相关信息的**配置块**
+ 通道包含**成员资格服务提供程序**实例，允许从不同的证书颁发机构派生加密材料

## 隐私

`Hyperledger Fabric`在每个**通道**的基础上使用不可变**分类账本**，以及可以操纵和修改**资产**的当前状态（即更新键值对）的**链代码**。分类账本存在于**通道**范围内，它可以在**整个网络中**共享（假设每个参与者在一个公共通道上运营），或者它可以**私有化**以仅包括一组特定的参与者。

在后一种情况下，这些参与者将创建一个**单独的通道**，从而**隔离他们的分类账本和交易**。为了解决公开透明性和私密性之前差距的应用场景，可以**仅在需要访问资产状态和执行读取、写入的对等体节点上安装链码**（换句话说，如果未在对等体上安装链码，它将无法与分类账本正确的连接）。

当该通道上的组织子集需要**保密其交易**数据时，**私有数据集合**用于将此数据**隔离**在私有数据库中。**在逻辑上与通道分类账本分开，只能由授权的分类账本访问**。

因此，通道保持交易从**更广泛的网络中**保密，而集合使数据在**通道上的组织子集之间**保持私密。

为了进一步**混淆数据**，将在**交易发送到排序服务并将区块添加到分类账本**之前，可以使用诸如AES之类的**公共加密算法对链码内的值进行加密**（部分或全部）。一旦加密数据被写入分类帐本，它就只能由**拥有**用于生成密文的相应**密钥的用户解密**。

## 安全和会员服务

`Hyperledger Fabric`支持**交易网络**，所有参与者都**拥有已知的合法身份**。公钥基础结构用于**生成与组织绑定的加密证书**、网络组件和最终用户或客户端应用程序。因此，可以在更**广泛的网络和通道**级别上**操纵和管理数据访问控制**。`Hyperledger Fabric`的这种“许可”概念，加上通道的存在和功能，有助于解决**隐私和机密性**是最重要的问题。

## 共识

在分布式分类帐技术中，最近共识已成为单个函数内特定算法的同义词。然而，共识不仅包括简单地就**交易顺序达成一致**，而且`Hyperledger Fabric`通过其在整个**交易流程中的基本角色**，从**提案和认可、到排序、验证和提交**，突出了这种区别。简而言之，共识被定义为**构成块的一组交易的正确性的完整的循环验证**。

当块的**交易的订单和结果**满足明确的**策略标准检查**时，最终会**达成共识**。这些**检查和平衡**发生在交易的生命周期中，并包括使用**认可策略**来指定**哪些特定成员必须认可某个交易类**，以及**系统链代码以确保强制执行和维护这些策略**。在提交之前，**对等对等节点**将使用这些**系统链代码来确保存在足够的认可**，并且它们来自适当的实体。此外，在**包含交易**的任何块添加到分类帐之前，将进行**版本控制检查**，在此期间，分类账本的当前状态被同意。最终检查可**防止双重花费**操作和可能危及**数据完整性**的其他威胁，并允许针对非静态变量执行功能。

除了发生的大量背书认可，**有效性和版本控制检查**之外，还在**交易流的所有方向上发生持续的身份验证**。访问控制列表在网络的层次结构层上实现（将服务排序到通道），和有效负载重复签名验证和身份验证，交易提案通过不同的架构组件。总而言之，共识不仅限于一批交易的特定订单；相反，它是一种总体特征，是在交易从提案到提交的过程中进行的持续验证的副产品。

# `Identity` 身份

## 什么是身份

区块链网络中的不同参与者包括`Peer`、`Orderer`、客户端应用程序，管理员等。这些参与者中的每一个（网络内部或外部能够**使用服务**的活动元素） 都具有封装在`X.509`数字证书中的数字身份。这些身份确实很重要，因为它们**确定了对资源的具体权限以及对参与者在区块链网络中拥有的信息的访问权限**。

此外，数字身份还具有`Fabric`用于确定权限的一些其他属性，并且它为身份和关联属性的并集提供了特殊名称 - **主体 Principal**。`Principal` 就像`userIDs`或`groupIDs`，但更灵活一点，因为它们可以包含参与者的身份的各种属性，例如参与者的组织，组织单位，角色甚至是参与者的特定身份。当我们谈论主体时，它们是决定其权限的属性。

要使身份可以**验证**，它必须来自**可信任的**权威机构。[成员的服务提供商](https://hyperledger-fabric.readthedocs.io/en/latest/membership/membership.html) （`MSP`）是如何实现的`Fabric`。更具体地说，`MSP`是定义管理该组织的**有效身份规则**的组件。`Fabric`中的默认`MSP`实现使用`X.509`证书作为身份，采用传统的公钥基础结构（`PKI`）分层模型（稍后将详细介绍`PKI`）。

## 身份的使用场景

想象一下，你去超市购买一些杂货。在结账时，会看到一个标志，表示只接受`Visa`，`Mastercard`和`AMEX`卡。如果您尝试使用其他卡付款， 无论该卡是否真实且您的帐户中有足够的资金都无关紧要。它不会被接受！

![identity](https://hyperledger-fabric.readthedocs.io/en/latest/_images/identity.diagram.6.png)

**拥有有效的信用卡是不够的，它也必须被商店接受！`PKI`和`MSP`以相同的方式协同工作。`PKI`提供身份列表，`MSP`说哪些是参与网络的给定组织的成员**。

`PKI`证书颁发机构和`MSP`提供了类似的功能组合。`PKI`就像一个卡提供商，它分配了许多不同类型的可验证身份。另一方面，`MSP`类似于商店接受的卡提供商列表，确定哪些身份是商店支付网络的可信成员（参与者）。**`MSP`将可验证的身份转变为区块链网络的成员**。

## 什么是`PKI`

**公钥基础结构（`PKI`）是一组互联网技术，可在网络中提供安全通信**。它是将**`PK`放入`HTTPS`的`PKI`**，如果您在网络浏览器上阅读本文档，您可能正在使用`PKI`来确保它来自经过验证的来源。

![PKI](https://hyperledger-fabric.readthedocs.io/en/latest/_images/identity.diagram.7.png)

公钥基础结构（`PKI`）的元素。`PKI`由向各方（例如，服务的用户，服务提供商）**发布数字证书的证书颁发机构**组成，然后使用它们在与其环境交换的消息中对自己进行认证。**`CA`的证书吊销列表（`CRL`）构成不再有效的证书**的参考。证书的撤销可能由于多种原因而发生。例如，证书可能被撤销，因为与证书相关联的加密私有材料已被公开。

虽然区块链网络不仅仅是一个通信网络，但它**依赖于`PKI`标准来确保各个网络参与者之间的安全通信**，并**确保在区块链上发布的消息得到正确的认证**。因此，了解`PKI`的基础知识以及为什么`MSP`如此重要是非常重要的。

`PKI`有四个关键要素：

- **数字证书**
- **公钥和私钥**
- **证书颁发机构**
- **证书撤销列表**

## 数字证书

**数字证书是包含与证书持有者有关的一组属性的文档**。最常见的证书类型是以[X.509标准](https://en.wikipedia.org/wiki/X.509)的证书，它允许在其结构中编码一方的识别细节。

描述一个名为`Mary Morris`的当事人的**数字证书**。`Mary`是`SUBJECT`证书的副本，突出显示的`SUBJECT`文本显示了关于`Mary`的重要。如您所见，证书还包含更多信息。最重要的是，`Mary`的公钥是在她的证书中分发的，而她的私人签名密钥则不是，**此签名密钥必须保密**。

重要的是，玛丽的**所有属性**都可以**使用称为密码学的数学技术**进行记录，这样**篡改将使证书无效**。只要对方信任证书颁发者，称为**证书颁发机构**（CA），**密码学就允许`Mary`将证书提交给其他人以证明身份**。只要`CA`安全地保存某些加密信息（意味着它自己的**私人签名密钥**），任何阅读证书的人都可以确定有关`Mary`的信息没有被篡改，它将始终具有`Mary Morris`的特定属性。将`Mary`的`X.509`证书视为无法改变的数字身份证。

## 身份验证、公钥和私钥

**身份验证和消息完整性是安全通信中的重要概念**。身份验证要求确保交换消息的各方**创建特定消息的身份**。对于具有**完整性**的消息意味着**在其传输期间不能被修改**。例如，可能希望确保与真正的玛丽莫里斯而不是模仿者进行沟通。或者，如果Mary向您发送了一条消息，您可能希望确保其在传输过程中没有被其他任何人篡改过。

传统的身份验证机制依赖于**数字签名**，顾名思义，它允许一方对其消息进行数字**签名**。**数字签名还可以保证签名消息的完整性**。

从技术上讲，**数字签名机制要求每一方保存两个加密连接的密钥**：**广泛可用的公钥和充当认证的私钥**，以及用于在消息上产生**数字签名**的私钥 。数字签名消息的接收者可以通过检查**附加签名**在预期发送者的**公钥**下是否有效来验证接收消息的**来源和完整性**。

**私钥和相应公钥之间的唯一关系是使安全通信成为可能的加密魔法**。密钥之间的唯一数学关系使得**私钥**可以用于在仅**对应的公钥**可以匹配的消息上**产生签名**，并且**仅在相同的消息上**。

![AuthenticationKeys](https://hyperledger-fabric.readthedocs.io/en/latest/_images/identity.diagram.9.png)

在上面的示例中，`Mary`使用她的私钥对邮件进行签名。任何使用她的**公钥**查看签名消息的人都可以**验证签名**。

## 证书颁发机构

参与者或节点能够通过由**系统信任的机构**为其发布的**数字身份**参与区块链网络。在最常见的情况下，数字身份（或简称**身份**）具有符合`X.509`标准并由证书颁发机构（`CA`）颁发的经**加密验证**的数字证书的形式。

`CA`是互联网安全协议的常见部分，可能已经听说过一些比较流行的协议：`Symantec`（最初是`Verisign`），`GeoTrust`，`DigiCert`，`GoDaddy`和`Comodo`等。

![CertificateAuthorities](https://hyperledger-fabric.readthedocs.io/en/latest/_images/identity.diagram.11.png)

**证书颁发机构向不同的参与者分发证书**。这些证书由CA进行**数字签名**，并将**参与者与参与者的公钥**绑定在一起（并且可选地具有所有的属性列表）。因此，如果一个人**信任CA**（并且知道其公钥），则可以**信任**特定参与者**绑定到证书中包含的公钥**，并通过验证参与者证书上的CA签名来拥有所包含的属性。

证书可以广泛传播，因为它们既不包括**参与者**也不包括**CA的私钥**。因此，它们可以用作信任的锚节点，用于**验证来自不同参与者的消息**。

**CA也有一个证书，它们可以广泛使用**。这允许由给定CA**发布的身份**的消费者通过检查证书只能由**相应私钥（CA）的持有者**生成来验证它们。 

在区块链设置中，**每个希望与网络互动的参与者都需要一个身份**。在此设置中，您可能会说**一个或多个CA**可用于**从数字角度定义组织的成员**。CA是为组织的参与者提供**可验证的数字身份的基础**。

### 根`CA`，中间`CA`和信任链

CA的有两种形式：**根CA**和**中间CA**。由于`Root CA`（`Symantec`、`Geotrust`等）必须安全地向互联网用户**分发**数亿个证书，因此将此流程**分散到所谓的中间CA中**是有意义的。这些中间CA的**凭证**由**根CA或其他中间机构颁发**，允许为链中任何CA颁发的任何证书**建立“信任链”**。追溯到根CA的这种能力不仅允许CA的**功能扩展**，同时仍然提供安全性，允许使用证书的组织**充分信任**地使用中间CA，它限制了根CA的暴露，如果受到损害，将**危及整个信任链**。另一方面，如果中级CA受到损害，则曝光量会小得多。

![ChainOfTrust](https://hyperledger-fabric.readthedocs.io/en/latest/_images/identity.diagram.1.png)

只要每个中间CA的证书的颁发CA是**根CA本身**或具有对**根CA的信任链**，就在**根CA和一组中间CA之间建立信任链**。

中间CA在**跨多个组织**颁发证书时提供了巨大的**灵活性**，这在许可的区块链系统（如`Fabric`）中非常有用。例如，将看到**不同的组织可能使用不同的根CA**，或者使用具有**不同中间CA的相同根CA** ，它确实取决于网络的需求。

### `Fabric CA`

这是因为CA非常重要，`Fabric`提供了一个**内置的CA组件**，允许在**构成的区块链网络中创建CA**。此组件（称为`Fabric CA`）是一个**私有根CA提供程序**，能够管理具有`X.509`证书形式的`Fabric`参与者的**数字身份**。由于`Fabric CA`是针对`Fabric`的**根CA**需求的自定义CA，因此它本身无法为浏览器中的**创建/自动**使用提供`SSL`证书。但是，由于某些CA必须用于**管理身份**（即使在测试环境中），因此可以使用`Fabric CA`来提供和管理证书。使用**公共/商业根或中间CA**来提供识别也是可能的，并且完全合适。

## 证书撤销列表

证书撤销列表（`CRL`）很容易理解，它只是CA知道由于某种原因而被**撤销的证书的引用列表**。如果回想一下商店场景，`CRL`就像被盗信用卡列表一样。

**当第三方想要验证另一方的身份时，它首先检查颁发CA的`CRL`以确保证书尚未被撤销**。验证者不必检查`CRL`，但如果不是，则他们冒着接受**受损身份的风险**。

![CRL](https://hyperledger-fabric.readthedocs.io/en/latest/_images/identity.diagram.12.png)

使用CRL检查证书是否仍然有效。如果模仿者试图将受损的数字证书传递给验证方，则可以**首先检查颁发CA的CRL**，以确保其未列为不再有效。

请注意，**被撤销的证书与证书过期非常不同**。撤销的证书尚未过期，按其他措施，**它们是完全有效的证书**。有关CRL的更多深入信息，[请单击此处](https://hyperledger-fabric-ca.readthedocs.io/en/latest/users-guide.html#generating-a-crl-certificate-revocation-list)。

# `Membership` 会员

如果已经阅读了有关身份的文档，那么已经了解了`PKI`如何通过信任链提供可验证的身份。现在让我们看看这些身份如何用于表示区块链网络的**可信成员**。

这就是**会员服务提供商**（`MSP`）发挥作用的地方，它**确定了哪些根CA和中间CA被信任来定义信任域**的成员，例如：一个组织，通过列出其成员的身份，或者通过识别哪些CA被授权为其成员发布有效身份，或者通常是这种情况通过两者的组合。

`MSP`的强大功能不仅仅是**列出谁是网络参与者或通道成员**。`MSP`可以识别参与者可能在`MSP`所代表的组织范围内发挥的**特定角色**（例如，管理员，或作为子组织组的成员），并**设置在网络和通道**（例如，通道管理员，读者，作家）的**上下文**中定义**访问权限**的基础。

`MSP`的配置被通告给相应组织的成员参与的**所有通道**（以通道`MSP`的形式）。除了通道`MSP`、对等节点、`Orderer`和客户端之外，还维护本地`MSP`以对**通道上下文之外的成员消息进行身份验证**，并定义对特定组件（具有在对等节点方上**安装链代码**的能力）的权限。

此外，`MSP`可以允许**识别已被撤销的身份列表**，如身份文档中所述。但我们将讨论该流程如何扩展到`MSP`。

## 将`MSP`映射到组织

**组织**是一组**受管理的成员**。这可以像跨国公司那样大，也可以像花店一样小。组织（`orgs`）最重要的是他们在一个`MSP`下**管理他们的成员**。请注意，这与`X.509`证书中定义的组织概念不同，我们将在稍后讨论。

组织与其`MSP`之间的独占关系使得在组织之后命名`MSP`是明智的，这是大多数策略配置中都会采用的约定。例如，组织`ORG1`可能会有一个名为`ORG1-MSP`的`MSP`。在某些情况下，组织可能需要多个成员资格组，例如，使用通道在组织之间执行非常不同的业务功能。在这种情况下是有意义的有多个`MSP`和因此他们的名字，例如，`ORG2-MSP-NATIONAL`和 `ORG2-MSP-GOVERNMENT`，反映了内部的信任的不同成员的根 `ORG2`在`NATIONAL`相对于销售通道`GOVERNMENT`的监管通道。

![MSP1](https://hyperledger-fabric.readthedocs.io/en/latest/_images/membership.diagram.3.png)

组织的两种不同`MSP`配置。第一个配置显示`MSP`与组织之间的典型关系，单个`MSP`定义组织成员列表。在第二种配置中，不同的`MSP`用于表示具有国家，国际和政府关联的不同组织组。

### 组织单位和`MSP`

组织通常被划分为多个**组织单位**（`OU`），每个**组织单位**都有一定的责任。例如，`ORG1` 组织可能有两个`ORG1-MANUFACTURING`和`ORG1-DISTRIBUTION` `OU`来反映这些独立的业务线。当`CA`颁发`X.509`证书时，证书中的`OU`字段指定标识所属的业务线。

稍后我们将看到`OU`如何有助于控制被视为区块链网络成员的组织部分。例如，只有来自`ORG1-MANUFACTURING` `OU`的身份可能能够访问通道，而`ORG1-DISTRIBUTION`不能。

最后，尽管这是对`OU`的轻微滥用，但它们有时可以被联盟中的不同组织用来区分彼此。在这种情况下，不同的组织将相同的根`CA`和中间`CA`用于其信任链，但是指定该`OU`字段以标识每个组织的成员。我们还将看到如何配置`MSP`以便以后实现此目的。

## 本地`MSP`和通道`MSP`

`MSP`出现在区块链网络中的两个位置：通道配置（**通道`MSP`**），以及在参与者的前提下**本地**（**本地`MSP`**）。**为客户端（用户）和节点（对等端和排序者）定义本地MSP**。本地节点`MSP`定义该节点的权限（例如，对等管理员是谁）。用户的本地`MSP`允许用户侧在其交易中作为通道的成员（例如，在链代码交易中）认证自身，或者作为特定角色的所有者在系统中进行认证（例如，在组织中的组织管理员）交易。

**每个节点和用户都必须定义一个本地MSP**，因为它定义了谁在该级别具有管理或参与权限（对等管理员不一定是通道管理员，反之亦然）。

相反，**通道MSP在通道层面定义了行政和参与权利**。参与通道的每个组织都必须为其定义`MSP`。通道上的对等体和排序者都将**共享相同的通道`MSP`视图**，因此能够正确地验证通道参与者。这意味着，如果组织希望加入该通道，则需要**将包含该组织成员信任链的`MSP`纳入通道配置**中。否则，将拒绝源自该组织身份的交易。

本地`MSP`和通道`MSP`之间的关键区别不在于它们如何运作，既将身份转变为角色，又是其**范围**。

![MSP2](https://hyperledger-fabric.readthedocs.io/en/latest/_images/membership.diagram.4.png)本地和背书`MSP`。每个对等体的信任域（例如，组织）由对等体的本地`MSP`定义，例如`ORG1`或`ORG2`。通过将组织的`MSP`添加到通道配置来实现组织在通道上的表示。例如，该图的通道由`ORG1`和`ORG2`管理。类似的原则适用于网络，排序者和用户，但为简单起见，此处未显示这些原则。 

通过查看区块链管理员安装和实例化智能合约时会发生什么，您可能会发现如何使用本地`MSP`和通道`MSP`很有帮助，如上[图所示](https://hyperledger-fabric.readthedocs.io/en/latest/membership/membership.html#msp2img)。

管理员`B`使用由`RCA1` 本地`MSP` 发布并存储在其本地`MSP`中的标识连接到对等方。当`B`尝试在对等体上安装智能合约时，对等体检查其本地`MSP` `ORG1-MSP`，以验证其身份`B`确实是其成员`ORG1`。成功验证将允许`install`命令成功完成。随后，`B`希望在通道上实例化智能合约。因为这是一个通道操作，所以通道上的所有组织都必须同意。因此，对等方必须先检查通道的`MSP`，然后才能成功提交此命令。（其他事情也必须发生，但现在集中精力于上述。）

**本地MSP仅在**它们应用**的节点或用户的文件系统上定义**。因此，在物理上和逻辑上，每个节点或用户只有一个本地`MSP`。但是，由于通道`MSP`可用于通道中的所有节点，因此它们在通道配置中进行逻辑定义一次。但是， **通道MSP也在通道中每个节点的文件系统上实例化，并通过一致性保持同步**。因此，虽然每个节点的本地文件系统上存在每个通道`MSP`的副本，但逻辑上`MSP`通道驻留在该通道上并由通道或网络维护。

## MSP级别

通道和本地`MSP`之间的分离反映了组织管理其本地资源（例如对等或排序者节点）及其背书资源（例如在背书或网络级别运营的分类帐，智能合约和财团）的需求。将这些`MSP`视为处于不同**层次**是有帮助的，**MSP处于与网络管理问题相关的更高级别，**而**较低级别的MSP处理私有资源管理的身份**。`MSP`在每个管理级别都是必需的，必须为网络，背书，对等，排序者和用户定义`MSP`。

![MSP3](https://hyperledger-fabric.readthedocs.io/en/latest/_images/membership.diagram.2.png)

`MSP`级别：对等体和排序者的`MSP`是本地的，而通道的`MSP`（包括网络配置通道）在该通道的所有参与者之间共享。在此图中，网络配置通道由`ORG1`管理，但另一个应用程序通道可由`ORG1`和`ORG2`管理。对等体是`ORG2`的成员和管理者，而`ORG1`管理图的排序者。`ORG1`信任来自`RCA1`的身份，而`ORG2`信任来自`RCA2`的身份。请注意，这些是管理身份，反映了谁可以管理这些组件。因此，当`ORG1`管理网络时，`ORG2.MSP`确实存在于网络定义中。

+ **网络MSP**：网络的配置定义了谁是网络中的成员，通过定义参与组织的`MSP` ，以及这些成员中的哪些成员被授权执行管理任务（例如，创建通道）。
+ **通道MSP**：通道必须单独维护其成员的`MSP`。**通道在特定的一组组织之间提供私人通信**，这些组织又对其进行管理控制。在通道的`MSP`环境中解释的通道策略定义谁有能力参与通道上的某些行动，例如，添加组织或实例化链码。请注意，管理通道的权限与管理网络配置通道（或任何其他通道）的权限之间没有必然的关系。管理权限存在于管理范围内（除非规则已经另行规定 - 请参阅`ROLE`下面对属性的讨论）。
+ **对等MSP**：此本地`MSP`在每个对等体的文件系统上定义，并且每个对等体都有一个`MSP`实例。从概念上讲，它执行与通道`MSP`完全相同的功能，其限制是它仅适用于定义它的对等方。使用对等方的本地`MSP`评估其授权的操作的示例是在对等方上安装链代码。
+ **Orderer MSP**：与对等`MSP`一样，**orderer**本地`MSP`也在节点的文件系统上定义，仅适用于该节点。与对等节点一样，`orderers`也由单个组织拥有，因此只有一个`MSP`来列出它信任的参与者或节点。

## MSP结构

到目前为止，已经看到`MSP`最重要的元素是用于在相应组织中建立参与者或节点成员资格的根`CA`或中间`CA`的规范。但是，有更多的元素与这两个元素结合使用以协助成员函数。

![MSP4](https://hyperledger-fabric.readthedocs.io/en/latest/_images/membership.diagram.5.png)

上图显示了本地`MSP`如何存储在本地文件系统中。尽管通道`MSP`的物理结构并非如此，但它仍然是一种有用的思考方式。

`MSP`有九个元素。最简单的方法是在目录结构中考虑这些元素，其中`MSP`名称是根文件夹名称，每个子文件夹代表`MSP`配置的不同元素。

让我们更详细地描述这些文件夹，看看它们的重要性：

+ **根`CA`**：此文件夹包含由此`MSP`表示的组织信任的根`CA`的自签名`X.509`证书列表。此`MSP`文件夹中必须至少有一个`Root CA X.509`证书。

  这是最重要的文件夹，因为它标识了必须从中派生所有其他证书才能被视为相应组织的成员的`CA`。

+ **中间`CA`**：此文件夹包含此组织信任的中间`CA`的`X.509`证书列表。每个证书必须由`MSP`中的一个根`CA`或中间`CA`签名，中间`CA`的颁发`CA`链最终会返回到受信任的根`CA`。

  中间`CA`可以表示组织的不同细分（如`ORG1-MANUFACTURING`和`ORG1-DISTRIBUTION`做`ORG1`），或组织本身（如果商业`CA`用于组织的身份管理，则可能是这种情况）。在后一种情况下，中间`CA`可用于表示组织细分。[在这里，](https://hyperledger-fabric.readthedocs.io/en/latest/msp.html)您可以找到有关`MSP`配置最佳实践的更多信息。请注意，可能有一个没有中间`CA`的正常运行的网络，在这种情况下，此文件夹将为空。

  与根`CA`文件夹一样，此文件夹定义必须颁发证书才能被视为组织成员的`CA`。

+ **组织单位（`OU`）**：这些单位列在`$FABRIC_CFG_PATH/msp/config.yaml` 文件中，包含一个组织单位列表，其成员被视为该`MSP`所代表的组织的一部分。当您希望将组织成员限制为拥有其中包含特定`OU`的身份（由`MSP`指定的`CA`之一签名）的成员时，此功能尤其有用。

  指定`OU`是可选的。如果未列出任何`OU`，则作为`MSP`一部分的所有身份（由根`CA`和中间`CA`文件夹标识）将被视为组织的成员。

+ **管理员**：此文件夹包含一个标识列表，用于定义具有此组织管理员角色的角色。对于标准`MSP`类型，此列表中应该有一个或多个`X.509`证书。

  值得注意的是，仅仅因为一个参与者具有管理员的角色，并不意味着他们可以管理特定的资源！给定标识在管理系统方面的实际功率由管理系统资源的策略决定。例如，通道策略可能指定`ORG1-MANUFACTURING` 管理员有权将新组织添加到背书，而 `ORG1-DISTRIBUTION`管理员则没有此类权限。

  即使`X.509`证书具有一个`ROLE`属性（例如，指定一个参与者是一个`admin`），这指的是一个参与者在其组织内而不是在区块链网络中的角色。这类似于`OU`属性的目的，如果已定义属性，则指的是参与者在组织中的位置。

  如果已编写该通道的策略以允许组织（或某些组织）的任何管理员执行某些通道功能（例如实例化链代码），则该`ROLE`属性**可**用于在通道级别授予管理权限。通过这种方式，组织角色可以赋予网络角色。

+ **撤销证书**：如果**已撤销参与者**的身份，则在此文件夹中保存有关身份的信息， 而不是身份本身。对于基于`X.509`的标识，这些标识符是称为主题密钥标识符（`SKI`）和授权访问标识符（`AKI`）的字符串对，并且只要使用`X.509`证书来确保证书未被证实，就会对其进行检查。撤销。

  此列表在概念上与`CA`的证书吊销列表（`CRL`）相同，但它也与从组织中撤消成员身份有关。因此，`MSP`（本地或通道）的管理员可以通过向`CA`发布的已撤销证书发布更新的`CRL`来快速撤销组织中的参与者或节点。这个“列表列表”是可选的。它只会在证书被撤销时填充。

+ **节点标识**：此文件夹包含**节点的标识**，即加密材料与内容的组合`KeyStore`，将允许节点在发送给其通道和网络的其他参与者的消息中验证自身。对于基于`X.509`的标识，此文件夹包含**`X.509`证书**。这是对等体在交易提议响应中放置的证书，例如，用于指示对等方已经认可它，随后可以在验证时针对结果交易的认可策略进行检查。

  此文件夹对于本地`MSP`是必需的，并且该节点必须只有一个`X.509`证书。它不用于通道`MSP`。

+ **`KeyStore`对于私钥**：此文件夹是为对等或排序者节点（或客户端的本地`MSP`）的本地`MSP`定义的，并包含节点的**签名密钥**。此密钥以加密方式匹配**节点标识** 文件夹中包含的**节点标识**，并用于签署数据。例如签署交易提议响应，作为认可阶段的一部分。

  此文件夹对于本地`MSP`是必需的，并且必须只包含一个私钥。显然，对此文件夹的访问权限必须仅限于对等人具有管理职责的用户的身份。

  **通道MSP的**配置不包括此文件夹，因为通道`MSP`仅旨在提供身份验证功能而不是签名功能。

+ **`TLS`根`CA`**：此文件夹包含此组织信任的**用于TLS通信**的根`CA`的自签名`X.509`证书列表。`TLS`通信的一个示例是当对等方需要连接到订货人以便它可以接收分类帐更新时。

  `MSP TLS`信息涉及网络内的节点对等体和排序者，换句话说，而不是消耗网络的应用程序和管理。

  此文件夹中必须至少有一个`TLS`根`CA X.509`证书。

+ **`TLS`中间`CA`**：此文件夹包含由该`MSP`所代表的组织信任的名单中间`CA`证书的`CA` **的`TLS`通信**。当商业`CA`用于组织的`TLS`证书时，此文件夹特别有用。与成员资格中间`CA`类似，指定中间`TLS CA`是可选的。

# `Peer` 对等节点

区块链网络主要由**一组对等节点组成**。对等节点是网络的基本要素，因为他们主持**分类账和智能合约**。回想一下，**分类账**可以不可避免地**记录智能合约（或链码）生成的所有交易**。**智能合约和分类帐**分别用于封装网络中的**共享进程和共享信息**。排序的这些方面使他们成为了解`Hyperledger Fabric`网络的良好起点。

区块链网络的其他元素当然很重要：分类帐和智能合约，共识，策略，通道，应用程序，组织，身份和成员资格，可以在自己的专门章节中阅读更多相关信息。本节重点介绍对等体及其与`Hyperledger Fabric`网络中其他元素的关系。

![Peer1](https://hyperledger-fabric.readthedocs.io/en/latest/_images/peers.diagram.1.png)

区块链网络由对等节点组成，每个对等节点可以保存**分类账的副本和智能合约的副本**。在该示例中，网络`N`由对等体`P1`，`P2`和`P3`组成，每个对等体保持它们自己的分布式分类帐`L1`的实例。`P1`，`P2`和`P3`使用相同的链码`S1`来访问其分布式分类帐的副本。

可以创建，启动，停止，重新配置甚至删除对等体。它们公开了一组`API`，使管理员和应用程序能够与他们提供的服务进行交互。我们将在本节中详细了解这些服务。

## 术语解释

`Hyperledger Fabric`采用一种技术概念实现**智能合约**，它称之为**链码**。 只是一段访问分类账的代码，用一种支持的编程语言编写。在本主题中，我们通常使用术语链代码，但如果您更习惯该术语，请随意将其作为智能合约阅读。这是同一件事！

## 分类账本和智能合约

让我们更详细地看一下排序。我们可以看到**它是托管分类帐和链代码**的排序。更准确地说，**对等体实际上托管分类帐的实例和链代码的实例**。请注意，这在`Fabric`网络中提供了有意的冗余，它**避免了单点故障**。我们将在本节后面详细了解区块链网络的分布式和分散性。

![Peer2](https://hyperledger-fabric.readthedocs.io/en/latest/_images/peers.diagram.2.png)

对等体托管分类帐实例和链代码实例。在此示例中，`P1`承载分类帐`L1`的实例和链代码`S1`的实例。可以在单个对等体上托管许**多分类帐和链代码**。

由于**对等方是分类帐和链代码的主机**，因此应用程序和管理员必须与对等方**进行交互**才能访问这些资源。这就是为什么`peer`被认为是`Hyperledger Fabric`网络最基本的构建块。**首次创建对等体时，它既没有分类账，也没有链码**。稍后我们将看到如何在排序上创建分类帐以及如何安装链代码。

### 多个分类账本

对等方能够托管多个分类帐，这很有用，因为它允许**灵活的系统设计**。最简单的配置是让对等方管理单个分类帐，但对于对等方来说，在需要时托管两个或多个分类帐绝对合适。

![Peer3](https://hyperledger-fabric.readthedocs.io/en/latest/_images/peers.diagram.3.png)

托管多个分类帐的对等方。对等方托管一个或多个分类帐，每个分类帐具有零个或多个适用于它们的链代码。在这个例子中，我们可以看到对等体`P1`托管分类账`L1`和`L2`。使用链码`S1`访问分类帐`L1`。另一方面，可以使用链码`S1`和`S2`访问`Ledger L2`。

尽管对等体完全有可能在**没有托管**任何访问该**分类帐**的**链代码**的情况下托管分类帐实例，但很少有对等方以这种方式配置。**绝大多数对等体将至少安装一个链代码，可以查询或更新对等方的分类帐实例**。值得一提的是，无论用户是否安装了外部应用程序使用的链代码，**对等体还具有始终存在的特殊系统链代码**。本主题中未详细讨论这些内容。

### 多个链码

对等方拥有的分类账数量与可以访问该分类账的链代码数量之间没有固定的关系。对等体可能有许多链码和许多分类账。

![Peer4](https://hyperledger-fabric.readthedocs.io/en/latest/_images/peers.diagram.4.png)

上图是：托管多个链代码的对等方的示例。**每个分类帐都可以有许多访问它的链代码**。在这个例子中，我们可以看到对等体`P1`托管分类账`L1`和`L2`，其中`L1`由链代码`S1`和`S2`访问，`L2`由`S1`和`S3`访问。我们可以看到`S1`可以访问`L1`和`L2`。

稍后我们会看到为什么`Hyperledger Fabric`中的**通道**概念在同级托管多个分类帐或多个链代码时很重要。

## 应用程序和对等节点

我们现在将展示应用程序如何与对等方交互以访问分类帐。分类帐查询交互涉及应用程序和对等方之间的简单三步对话。分类帐更新交互涉及更多，需要两个额外的步骤。我们已经简化了这些步骤以帮助您开始使用`Hyperledger Fabric`，但不要担心，最重要的是要理解的是，与分类帐更新交易风格相比，分类帐查询的应用程序 - 对等交互的差异。

应用程序在需要**访问分类帐和链代码时始终连接到对等方**。`Hyperledger Fabric`软件开发工具包（`SDK`）使程序员易于使用，**它的`API`使应用程序能够连接到对等端，调用链式代码以生成交易，将交易提交到将共识节点并提交到分布式分类帐的网络，以及在接收事件时接收事件这个过程完成了**。

通过对等连接，应用程序可以**执行链代码来查询或更新分类帐**。分类帐查询交易的结果立即返回，而分类帐更新涉及应用程序、对等节点和共识节点之间更复杂的交互。让我们更详细地研究一下。

![Peer6](https://hyperledger-fabric.readthedocs.io/en/latest/_images/peers.diagram.6.png)

排序节点与共识节点一起**确保分类账与每个排序保持同步**。在此示例中，应用程序`A`连接到`P1`并调用链代码`S1`来查询或更新分类帐`L1`。`P1`调用`S1`以生成包含查询结果或建议的分类帐更新的提议响应。应用程序`A`接收提议响应，对于查询，该过程现在已完成。对于更新，`A`从所有响应构建一个交易，并将其发送给`O1`进行排序。`O1`将来自网络的交易收集到块中，并将这些交易分发给所有对等体，包括`P1`。`P1`在申请`L1`之前验证交易。更新`L1`后，`P1`会生成`A`收到的事件，表示完成。

**对等体可以立即将查询结果返回给应用程序**，因为满足查询所需的所有信息都在**对等体的分类帐本地副本**中。对等方从不咨询其他对等方以响应来自应用程序的查询。但是，应用程序**可以连接到一个或多个对等方以发出查询**。例如，在**多个对等体之间确认结果**，或者如果**怀疑**信息可能**已过期**，则从另一个对等体检索更新的结果。在图中，您可以看到分类帐查询是一个**简单的三步过程**。

更新交易以与查询交易相同的方式启动，但还有**两个额外步骤**。虽然分类帐更新应用程序也连接到对等方以调用链代码，但与分类帐查询应用程序不同，**单个对等方此时无法执行分类帐更新**，因为其他**对等方必须首先同意此更改，称为共识的过程**。因此，对等方向应用程序返回提议的更新。该对等方将根据**其他对等方先前的协议应用该更新**。第一个额外步骤 —— 第四步：要求应用程序向**整个对等网络发送一组适当的匹配提议更新**，作为对其各自分类帐的**承诺**的交易。这是通过应用程序**使用`orderer`将交易打包到块中，并将它们分发到整个对等网络来实现的**，在应用于每个对等方的本地副本之前，可以对它们进行验证。由于整个排序处理需要一些时间才能完成（秒），因此将**异步通知应用程序**，如步骤5所示。

在本节的后面部分，将了解有关此排序过程的详细性质的更多信息，有关此过程的详细信息，请参阅“ [交易流程”](https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html)主题。

## 对等节点和通道

虽然这一部分是关于排序节点而不是通道，但是值得花些时间了解对等方如何相互交互，以及**通过通道与应用程序进行交互**，**区块链网络中的一组组件可以通过这种机制进行私密交流和交易**。

**这些组件通常是对等节点，共识节点和应用程序，并且通过加入通道，他们同意协作以共同共享和管理与该通道相关联的分类帐的相同副本**。从概念上讲，可以将通道视为与朋友群体相似（尽管通道成员当然不需要成为朋友）。一个人可能有几组朋友，每组都有他们一起做的活动。这些群体可能是完全独立的（与一群爱好朋友相比，一群工作朋友），或者他们之间可能存在一些交叉。然而，每个群体都是自己的实体，具有一种“规则”。

![Peer5](https://hyperledger-fabric.readthedocs.io/en/latest/_images/peers.diagram.5.png)

**通道允许一组特定的对等体和应用程序在区块链网络内相互通信**。在此示例中，应用程序`A`可以使用通道`C`直接与对等方`P1`和`P2`通信。可以将**通道视为**特定应用程序和对等方之间**通信的途径**。（为简单起见，此图中未显示共识服务，但必须存在于正常运行的网络中。）

我们看到通道的存在方式与对等方不同，将通道视为由物理对等体集合形成的逻辑结构更为合适。了解这一点至关重要，**对等节点提供了访问和管理通道的控制点**。

## 对等节点和组织

现在了解了排序节点及其与分类账，链码和通道的关系，将能够看到**多个组织**如何聚集在一起形成区块链网络。

区块链网络由**一组组织**而不是一个组织管理。对等体是如何构建这种分布式网络的核心，因为它们由这些组织所拥有，这些组织并且是网络的连接点。

![Peer8](https://hyperledger-fabric.readthedocs.io/en/latest/_images/peers.diagram.8.png)

与多个组织的区块链网络中的排序，**区块链网络由不同组织拥有和贡献的排序构建**。在此示例中，我们看到有四个组织贡献了八个对等组成网络。通道`C`连接网络`N-P1`，`P3`，`P5`，`P7`和`P8`中的这些对等体中的五个。这些组织拥有的其他排序尚未加入此通道，但通常会加入至少一个其他通道。由特定组织开发的应用程序将连接到自己组织的排序以及不同组织的排序。同样，为简单起见，此图中未显示排序者节点。

在区块链网络的形成过程中，可以看到正在发生的事情，这一点非常重要。**该网络由为其提供资源的多个组织形成和管理**。对等方是我们在本主题中讨论的资源，但组织提供的资源不仅仅是排序。这里有一个原则，如果没有组织将其个人资源贡献给集体网络，网络就不存在。此外，网络随着这些合作组织提供的资源而增长和缩小。

可以看到（除了排序服务之外）没有集中资源，在[上面](https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html#Peer8)的[示例中](https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html#Peer8)，如果组织没有贡献他们的排序共识节点，则网络**N**将不存在。这反映了这样一个事实，即网络不存在于任何有意义的意义上，除非并且直到组织贡献形成它的资源。此外，**网络不依赖于任何单个组织，只要一个组织仍然存在，它将继续存在**，无论其他组织可能加入或离开。这是网络分散的核心所在。

如上[例所示](https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html#Peer8)，不同组织中的应用程序可能相同也可能不同。这是因为它完全取决于组织如何处理其同行的分类账副本。这意味着**应用程序和表示逻辑可能因组织而异，即使它们各自的对等方托管完全相同的分类帐数据**。

**应用程序可以连接到组织中的对等方，也可以连接到其他组织中的对等方，具体取决于所需的分类帐交互的性质**。对于分类帐**查询交互**，应用程序通常**连接到自己组织的同级**。对于分类帐**更新交互**，我们稍后会看到为什么应用程序需要连接到代表**需要认可分类帐更新的*每个*组织的对等方**。

## 对等节点和身份

既然已经看到来自不同组织的同行节点如何聚集在一起形成区块链网络，那么值得花一些时间了解管理员如何将同事分配给组织。

对等方通过来自**特定**证书颁发机构的数字证书为其**分配身份**。可以阅读更多有关`X.509`数字证书如何在本指南的其他地方工作的内容，但是，现在将数字证书视为一张`ID`卡，它提供了许多关于同行的可验证信息。**管理员从其拥有的组织为网络中的每个对等方分配一个数字证书**。

![Peer9](https://hyperledger-fabric.readthedocs.io/en/latest/_images/peers.diagram.9.png)

当对等体连接到通道时，其数字证书通过通道`MSP`识别其拥有的组织。在此示例中，`P1`和`P2`具有由`CA1`发布的身份。通道`C`根据其通道配置中的策略确定来自`CA1`的身份应使用`ORG1.MSP`与`Org1`相关联。类似地，`ORG2.MSP`将`P3`和`P4`识别为`Org2`的一部分。

每当对等体使用通道连接到区块链网络时，**通道配置中的策略使用对等体的身份来确定其权限**。身份到组织的映射由称为**成员服务提供者**的组件**提供**（`MSP`)，它确定**如何将对等体分配给特定组织中的特定角色**，从而获得对区块链资源的**适当访问权限**。此外，**对等体只能由单个组织拥有**，因此与单个`MSP`相关联。我们将在本节后面详细了解对等访问控制，本指南的其他部分有关于`MSP`和访问控制策略的完整部分。但就目前而言，将`MSP`视为在区块链网络中提供个人身份与特定组织角色之间的联系。

为了离题，同行以及**与区块链网络交互的所有内容都从其数字证书和`MSP`获取其组织身份**。如果同行、应用程序、最终用户、管理员和通道者想要与区块链网络**进行交互**，则**必须拥有身份和相关的`MSP`**。**我们使用身份：主体为每个与区块链网络交互的实体命名**。可以在本指南的其他地方了解更多关于校长和组织的知识，但是现在已经了解了足够多的知识，可以继续了解同行！

最后，请注意，**对等体的物理位置并不重要，它可以驻留在云中**，也可以驻留在其中一个组织或本地计算机所拥有的数据中心中 。它是与之关联的标识，将其**标识为由特定组织拥有**。在上面的示例中，`P3`可以托管在`Org1`的数据中心，但只要与之关联的数字证书由`CA2`发布，那么它就由`Org2`拥有。

## 对等节点和`orderer`服务

我们已经看到，同行构成了区块链网络的基础。托管分类账和链码，可以通过对等节点连接的应用程序进行查询和更新。但是，**应用程序和对等方之间相互交互以确保每个对等方的分类帐保持一致**的机制由称为**`orderers`**的特殊节点**调解**，现在我们转向注意这些节点。

**更新交易与查询交易完全不同，因为单个对等体本身不能更新分类帐，更新需要网络中其他对等方的同意**。对等体要求网络中的**其他对等体批准**分类帐更新，然后才能将其应用于对等方的**本地分类帐**。此过程称为**共识**，与简单查询相比，需要更长的时间才能完成。但是，当需要批准交易的所有对等方都这样做，并且交易被提交到分类帐时，对等方将通知其连接的应用程序已更新分类帐。您将在本节中更详细地了解同行和通道者如何管理共识流程。

具体而言，想要更新分类帐的应用程序涉及三阶段过程，这可确保区块链网络中的**所有对等方保持其分类帐彼此一致**。在第一阶段，应用程序使用一个**支持对等方**的子集，每个对应方提供对应用程序的建议分类帐**更新的认可策略**，但不将建议的更新应用于其分类帐副本。在第二阶段，这些**单独的认可策略作为交易收集在一起并打包成块**。在最后阶段，这些块将被**分发回每个对等方，在每个对等方都验证每个交易，然后再应用于该对等方的分类帐副本**。

正如将看到的，`orderer`节点是此过程的核心，因此让我们更详细地研究应用程序和对等方如何使用`orderers`生成可以**一致应用于分布式复制分类帐的分类帐更新**。

### 第1阶段：提议

交易工作流的第1阶段**涉及应用程序和一组对等方之间的交互**，它不涉及通道者。第1阶段仅涉及一个应用程序，**要求不同组织支持同行同意所提议的链代码调用的结果**。

为了启动阶段1，应用程序**生成一个交易提议**，并将其**发送**给**每个**所需的**对等方以进行认可**。然后，这些**支持对等体中的**每一个使用交易提议**独立地执行链码**以**生成**交易提议**响应**。它不会将此更新应用于分类帐，而是简单地对其**进行签名**并将其**返回给应用程序**。一旦应用程序**收到足够数量的签名提议**响应，交易流程的第一阶段就完成了。让我们更详细地研究这个阶段。

![Peer10](https://hyperledger-fabric.readthedocs.io/en/latest/_images/peers.diagram.10.png)

交易提议由返回**认可的提议响应的同行节点独立执行**。在该示例中，应用程序`A1`生成交易`T1`提议`P`，其在通道`C`上发送给对等`P1`和对等`P2`。`P1`使用交易`T1`提议`P`执行`S1`，生成交易`T1`响应`R1`，它用`E1`认可。独立地`P2`使用交易`T1`提议`P`执行`S1`，生成交易`T1`响应`R2`，它与`E2`一起认可。应用程序`A1`接收针对交易`T1`的两个认可的响应，即`E1`和`E2`。

最初，**应用程序选择一组对等方来生成一组提议的分类帐更新**。应用程序选择哪些对等体？那么，这取决于**认可策略**（为链代码定义），**认可策略**定义了在网络接受之前**需要认可分类帐变更的组织集合**。这实际上是达成共识意味着什么 —— **每个重要的组织必须在任何同行分类账被接受之前批准提议的分类账变更**。

**对等方通过添加其数字签名并使用其私钥对整个有效负载进行签名来认可提议响应**。这种认可随后可用于证明该组织的同行产生了**特定的回应**。在我们的示例中，如果对等体`P1`由组织`Org1`拥有，则认可`E1`对应于“`Org1`的对等体`P1`已经提供了分类账`L1`上的交易`T1`响应`R1`！”的数字证据。

**当应用程序收到来自足够对等方的签名提议响应时**，阶段1结束 我们注意到，不同的对等体可以**为同一个交易提议**的应用程序返回不同的结果，因此**不一致的交易响应**。可能只是在**不同的对等体**上，在不同状态下的分类账生成结果，在这种情况下，应用程序可以简单地请求更新的提案响应。不太可能，但更严重的是，**结果可能会有所不同**，因为链码**是非确定性的**。非决定论是链码和分类账的敌人，如果它出现，则表明拟议交易存在严重问题，因为不一致的结果显然不适用于分类账。**单个对等方无法知道其交易结果是非确定性的**，在检测到非确定性之前，必须**将交易响应收集在一起进行比较**。（严格地说，即使这还不够，但我们将此讨论**推迟到交易部分**，其中详细讨论了非确定性。）

在阶段1结束时，如果应用程序愿意，应用程序可以**自由地丢弃不一致的交易响应**，从而有效地**提前终止**交易工作流程。稍后我们将看到，如果应用程序尝试使用一组不一致的交易响应来更新分类帐，它将被拒绝。

### 第2阶段：打包

交易工作流程的第二阶段是包装阶段。通道者对此过程至关重要，它**接收包含来自许多应用程序的认可交易提议响应的交易**。它将每个交易相对于其他交易**进行排序**，并**将批量交易打包成块**，准备好**分发回连接到订货人的所有对等方节点**，包括原始认可对等方。

![Peer11](https://hyperledger-fabric.readthedocs.io/en/latest/_images/peers.diagram.11.png)

订货人节点的第一个角色是打包提议的分类帐更新。在该示例中，应用程序`A1`将由`E1`和`E2`认可的交易`T1`发送到通道者`O1`。并行地，应用程序`A2`将由`E1`认可的交易`T2`发送到通道者`O1`。`O1`将来自应用程序`A1`的交易`T1`和来自应用程序`A2`的交易`T2`与来自网络中的其他应用程序的其他交易一起打包到块`B2`中。我们可以看到，在`B2`中，交易订单是`T1，T2，T3，T4，T6，T5` - 这可能不是这些交易到达订货人节点的顺序！（此示例显示了非常简化的通道者配置。）

通道者在**特定背书**上从网络中的许多不同应用程序**同时接收提议的分类帐更新**。它的工作是将这些提议的更新安排到明确定义的序列中，并将它们**打包成 块以供后续分发**。这些块将成为**区块**链的块！一旦通道者生成了所需大小的块，或者在最大经过时间之后，它将被**发送到在特定通道上连接到它的所有对等体**。我们将在第3阶段看到如何处理此块。

值得注意的是，**块中交易的顺序不一定与订货人交易的到达顺序相同**！交易可以按任**何顺序打包到一个块中**，而这个序列就成了**执行的顺序**。最重要的是，有**是一个严格的顺序**，而不是**什么**顺序是。

块内交易的这种严格排序使`Hyperledger Fabric`与其他区块链略有不同，其他区块链可以将相同的交易打包到多个不同的块中。在`Hyperledger Fabric`中，这不可能发生。由订单集合生成的块被认为是**最终的，**因为一旦将交易写入块，它在分类账中的位置就不可避免地得到保证。`Hyperledger Fabric`的最终结果意味着不会发生称为**分类账分叉**的灾难性事件。一旦在块中捕获交易，就**不能在将来的时间点为该交易重写历史记录**。

我们也可以看到，虽然同行节点主持分类账和链码，但最有可能没有。**到达订货人的每个交易都是机械地打包在一个区块中**，订货人不会对交易的价值做出判断，它只是打包它。这是`Hyperledger Fabric`的一个重要特性，**所有交易都被编组成严格的顺序，交易永远不会丢失或取消优先级**。

在第2阶段结束时，我们看到**订货人负责收集建议的交易更新**，通道它们，将它们打包成块，准备分发的简单但至关重要的过程。

### 第3阶段：验证

交易工作流的最后阶段涉及**从订货人到对等方的块的分发和后续验证**，其中它们可以应用于分类帐。具体而言，在每个对等方中，**块中的每个交易都经过验证**，以确保在将其应用于分类帐之前始终**得到所有相关组织的认可**。**保留失败的交易以进行审计，但不会应用于分类帐**。

![Peer12](https://hyperledger-fabric.readthedocs.io/en/latest/_images/peers.diagram.12.png)

`orderer`节点的第二个角色是**将块分发给对等体**。在该示例中，订货人`O1`将块`B2`分配给对等体`P1`和对等体`P2`。对等`P1`处理块`B2`，导致在`P1`上将新块添加到分类帐`L1`。并行地，对等体`P2`处理块`B2`，导致在`P2`上将新块添加到分类账`L1`。一旦完成该过程，就在对等体`P1`和`P2`上持续更新分类账`L1`，并且每个分类账可以通知连接的应用程序已经处理了该交易。

阶段3开始于订货人**将块分配给连接到它的所有对等体**。对等体连接到**通道上的通道者**，这样当生成新块时，连接到通道者的所有对等体将被**发送新块的副本**。每个对等体将**独立处理此块**，但其方式与通道上的每个其他对等体完全相同。通过这种方式，我们可以看到分类帐可以保持一致。值得注意的是，**不是每个对等体都需要连接到一个通道者**，对等体可以使用**gossip**协议将块**级联到其他对等体**，这些协议也可以独立处理它们。但是让我们把这个讨论留给另一个时间！

**收到一个块后，对等体将按照它在块中出现的顺序处理每个交易**。对于每笔交易，每个对等方将根据**认可政策**验证交易是否已得到所需组织的 **认可** 产生交易的链码的。例如，某些交易可能只需要由单个组织认可，而其他交易可能需要多次认可才能被视为有效。此验证过程验证所有相关组织是否已生成相同的结果。另请注意，此验证与第1阶段中的认可检查不同，在第1阶段，应用程序接收来自支持对等方的响应，并决定发送提议交易。**如果应用程序通过发送错误的交易违反了认可策略，则对等体仍然能够在阶段3的验证过程中拒绝该交易**。

**如果交易已正确认可，则对等方将尝试将其应用于分类帐**。为此，对等方必须执行分类帐**一致性检查**，以验证生成提议**更新时分类帐的当前状态**是否与分类帐的**状态兼容**。即使交易已**得到完全认可，这也可能并非总是可行**。例如，另一个交易可能已更新分类帐中的相同资产，使得交易更新不再有效，因此无法再应用。通过这种方式，每个对等方的分类帐副本在整个网络中保持一致，因为它们各自**遵循相同的验证规则**。

**在对等方成功验证每个单独的交易后，它会更新分类帐**。**失败**的交易**不会**应用于分类帐，但会将其**保留用于审计目的**，**成功的交易也是如此**。这意味着**对等块几乎与从订货人接收的块完全相同**，除了块中每个交易的有效或无效指示符。

我们还注意到**阶段3不需要运行链码**，这仅在阶段1期间完成，这很重要。这意味着只需**在背书节点上提供链码，而不是整个区块链网络**。这通常是有帮助的，因为它使链码的**逻辑保密以支持组织**。这与链路的输出（交易提议响应）形成对比，**链路输出与通道中的每个对等方共享**，无论它们是否认可交易。这种支持对等体的专业化旨在帮助**实现可伸缩性**。

最后，每次将块提交给对等方的分类帐时，该**对等方都会生成**适当的**事件**。**块事件**包括**完整块内容**，而**块交易事件**仅包括**摘要信息**，例如块中的每个交易是否已经过验证或无效。 **链**码执行产生的**Chaincode**事件也可以在此时发布。**应用程序可以注册这些事件**类型，以便在它们发生时**得到通知**。这些通知**结束了交易工作流程**的第三个也是最后一个阶段。

总之，阶段3看到由**订货人生成的块始终应用于分类帐**。将交易**严格排序**到块中允许每个对等体验证在区块链网络上**一致地应用交易更新**。

### `orderer`和共识

**整个交易工作流程**过程称为**共识**，因为所有同行都已在订单和交易商内容上**达成协议**，这一过程由**订货人调解**。共识是一个多步骤的过程，**只有在流程完成时，应用程序才会通知分类帐更新**。这可能会在不同的同行上**稍微不同的时间发生**。

在未来的`orderer`主题中更详细地讨论通道者，但是现在，将通道者视为从同行的应用程序**收集和分发**提议的分类帐更新以**验证和包含在分类帐中的节点**。

现在已经完成了对同伴以及`Hyperledger Fabric`中与之相关的其他组件的讲解。我们已经看到，对等方在很多方面都是最基本的元素。它们构成了网络，主机链代码和分类账，处理交易提议和响应，并通过始终如一地对其进行交易更新来使分类账保持最新状态。

# 私有数据

## 什么是私有数据？

如果**某个背书上的一组组织需要将该数据与该背书上的其他组织保密**，他们可以选择**创建一个新背书**，该背书仅包含**需要访问数据的组织**。但是，在每种情况下**创建单独的通道**会产生**额外的管理开销**（维护链代码版本，策略，`MSP`等），并且不允许您希望所有通道参与者在保留部分数据私有。

这就是为什么，从`v1.2`开始，`Fabric`提供了创建**私有数据集合**的能力 ，它允许**通道上定义的组织子集**能够支持**提交或查询私有数据**，而**无需创建单独的通道**。

## 什么是私有数据收集？

集合是两个元素的组合：

+ **实际的私有数据**，[通过`gossip`协议](https://hyperledger-fabric.readthedocs.io/en/latest/gossip.html)发送给对等节点只有**被授权**查看它的组织。此数据存储在**对等方的私有数据库中**（有时称为`side`数据库或`SideDB`）。这里不涉及订购服务，也没有看到私人数据。请注意，**设置`gossip`需要设置“锚点”对等节点，以便引导跨组织通信**。
+ **该数据的哈希值**，它**被认可、排序并写入通道上每个对等方的分类帐**。哈希用作事务的证据，用于状态验证，可用于审计目的。

下图说明了**授权拥有**私有数据的对等方的分类帐内容，以及**未拥有**私有数据的对等方的分类帐内容。 

![private data](https://hyperledger-fabric.readthedocs.io/en/latest/_images/PrivateDataConcept-2.png)

如果收集成员遇到**争议**或者想要将资产**转移**给第三方，可以决定**与其他方共享私人数据**。然后，第三方可以计算私有数据的**散列**，并查看它是否与通道分类帐上的**状态匹配**，从而证明在某个时间点集合成员之间存在状态。

### 何时使用通道内的集合与单独的通道

- 当整个交易（和分类账）***必须在作为通道成员***的一组**组织内保密**时，使用背书。
- 必须在一组**组织之间共享事务**（和分类帐）时使用**集合**，但是当这些组织中**只有一部分**应该可以**访问事务中的某些（或所有）数据时**。此外，由于私有数据是通过对等而**不是通过块传播**的，因此当事务数据必须保密以免订购服务节点时，请使用私有数据集合。

## 私有数据的交易流程

当在链代码中引用私有数据集合时，事务流程略有不同，以便在提交，认可和提交到分类帐的事务时**保护私有数据的机密性**。

有关不使用私有数据的事务流的详细信息，请参阅有关[事务流](https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html)的文档。

1. 客户端应用程序**提交提议请求**以调用链代码功能（**读取或写入私有数据**）以支持作为集合的**授权组织**的一部分的对等方。私有数据，或用于**在链码中生成私有数据**的数据，在提议的瞬态（`transient`）字段中发送。
2. 支持对等体**模拟事务**并将私有数据存储在**瞬态数据存储**(`transient data store`)（对等体本地的临时存储）中。他们根据收集策略通过`gossip`协议**将私有数据分发给授权的同行对等节点**。
3. 支持对等体使用**公共数据**将提议响应**发送回客户端**，包括私有数据**密钥和值的散列**。没有私人数据被发送回客户端。有关背书如何使用私人数据的更多信息，请单击[此处](https://hyperledger-fabric.readthedocs.io/en/latest/private-data-arch.html#endorsement)。
4. 客户端应用程序将**事务提交给订购服务**（**具有私有数据**的哈希值），**该服务正常地分配到块中**。具有散列值的块被**分发给所有对等体**。通过这种方式，**通道上的所有对等体**都可以以**一致**的方式验证具有**私有数据哈希值**的事务，而**无需知道实际的私有数据**。
5. 在块提交时，**授权对等方**使用**收集策略**来确定它们是否**有权**访问私有数据。如果他们这样做，他们将首先检查他们的**本地瞬态数据存储**(`transient data store`)，以确定他们是否已经在**链码背书时收到私人数据**。如果没有，他们将尝试从**另一个对等方提取私有数据**。然后，他们将针对**公共块中的哈希验证私有数据**，并提交事务和块。验证提交后，**私有数据将移动到其私有状态数据库和私有写入存储的副本**。然后从**瞬态数据存储中删除私有数据**。

### 用示例来解释集合

考虑交易产品的通道中的五个组织：

- **农民**在国外卖他的货物
- **经销商**将货物运往国外
- **托运人**在各方之间运送货物
- **批发商**从经销商处购买商品
- **零售商**从托运人和批发商处购买商品

**经销商**可能希望与**农民**和**托运人**进行私人交易，以保证交易条款对**批发商和零售商**保密（以免暴露他们正在收取的加价）。

**经销商**可能还希望与**批发商**建立单独的**私人数据**关系，因为它的价格低于零售商的价格。

**批发商**可能还希望与**零售商**和**托运人**建立私人数据关系。

不是为这些关系中的每一个定义许多小通道，而是**可以定义多个私有数据集合**（`PDC`）以在以下各项之间共享私有数据：

1. `PDC1`：**经销商**，**农民**和**托运人**
2. `PDC2`：**经销商**和**批发商**
3. `PDC3`：**批发商**，**零售商**和**托运人**

![private date](https://hyperledger-fabric.readthedocs.io/en/latest/_images/PrivateDataConcept-1.png)

使用此示例，**分销商**拥有的**同行节点**将在其**分类帐内部拥有多个私人数据库**，其中包括来自**分销商**，**农民**和**托运人**关系以及**分销商**和**批发商**关系的私人数据 。由于这些**数据库**与**保存通道分类帐的数据库保持独立**，因此私有数据有时称为“**SideDB**”。

![private-data.private-data](https://hyperledger-fabric.readthedocs.io/en/latest/_images/PrivateDataConcept-3.png)



## 如果定义私有数据集

有关集合定义以及有关私有数据和集合的其他低级信息的更多详细信息，请参阅[私有数据参考主题](https://hyperledger-fabric.readthedocs.io/en/latest/private-data-arch.html)。

## 清除数据

对于非常敏感的数据，即使是共享私有数据或者可能是政府法规要求，在一段时间后“**清除**”存储在其**同行节点**上的数据，只留下要服务的数据的**哈希值**作为**交易的不可改变的证据**。

在某些情况下，**私有数据**只需要存在于**对等方的私有数据库**中，直到它可以**复制**到区块链网络**外部的数据库**中。数据可能也只需要存在于对等体上，直到用它完成链码业务流程（交易结算，合同履行等）。为了支持后面的用例，一旦**将一定数量的后续块添加到私有数据库中，就可以清除私有数据**。

# `Ledger` 分类账本



## 什么是`Ledger`？

**分类帐包含作为交易日记帐的业务的当前状态**。最早的欧洲和中国分类账的历史可以追溯到近1000年前，而苏美尔人在 4000年前拥有[石头分类账](http://www.sciencephoto.com/media/686227/view/accounting-ledger-sumerian-cuneiform) ，但让我们从一个更新的例子开始吧！

你可能习惯每个月查看一下你的银行账户。对您来说最重要的是可用的余额，这是您在当前时刻可以花费的。如果您想了解您的余额是如何得出的，那么您可以查看确定它的交易信用和借方。这是分类账的真实例子： 一个州（您的银行余额），以及一组确定它的有序交易（信用和借方）。`Hyperledger Fabric`受到同样两个问题的驱动，呈现一组分类帐状态的当前值，并捕获确定这些状态的事务的历史记录。

## 区块链分类帐

区块链分类帐由两个不同但相关的部分组成，**世界状态和区块链**。 

首先，有一个**世界状态**： 一个数据库，它保存一组分类帐状态的**当前值**。**世界状态**使程序可以**轻松获取**这些**状态的当前值**，而不必通过**遍历**整个**事务日志**来计算它们。默认情况下，`Ledger`状态表示为**键值**对，但我们稍后会看到`Hyperledger Fabric`在这方面提供了灵活性。**世界状态可以经常变化，因为可以创建、更新和删除状态**。

其次，有一个**区块链**：一个**记录**决定**世界状态**的所有变化的**事务日志**。事务在块附加到区块链中的块内**收集** ，使您能够了解导致当前世界状态的更改**历史记录**。**区块链数据结构与世界状态非常不同，因为一旦编写，就无法修改**。它是一个**不可变**的块序列，每个块都包含**一组有序事务**。

![ledger.ledger](https://hyperledger-fabric.readthedocs.io/en/latest/_images/ledger.diagram.1.png)

事实表达的视觉词汇如下：`Ledger` L包括**区块链B**和**世界状态W**，**区块链B**确定**世界状态W**，也表示为：**世界状态W**源自**区块链B**。

考虑`Hyperledger Fabric`网络中有一个**逻辑**分类帐是有帮助的。实际上，**网络维护分类帐的多个副本**，通过称为**共识**的过程与每个**其他副本保持一致 **。术语**分布式分类帐技术**（`DLT`）通常与这种分类帐相关联。这种分类帐在逻辑上是**单一**的，但在整个网络中分布有**许多一致的副本**。

## 世界状态

**世界状态代表所有分类帐本状态的当前值**。它非常有用，因为**程序**通常需要分类帐状态的当前值，而且总是很容易获得。您**不需要遍历**整个区块链来计算任何分类帐状态的当前值，您只需直接从世界状态获取它。

![ledger.worldstate](https://hyperledger-fabric.readthedocs.io/en/latest/_images/ledger.diagram.3.png)

事实表达的视觉词汇如下：有一个分类帐状态，`key= CAR1`，`value=Audi`。有一个分类帐状态，其中`key = CAR2`且值更复杂`{model：BMW，color = red，owner = Jane}`。这两个值的版本都是`0`。

**分类帐状态**用于记录要通过**区块链共享**的应用**程序信息**。上面的例子显示了两辆汽车的**分类帐状态**，`CAR1`和`CAR2`。可以看到状态具有**键和值**。应用程序调用通过简单`API`访问状态的**链码** ，它们使用状态键**获取**，**添加**和 **删除**状态。注意状态值如何处理简单（奥迪......）或复杂（类型：宝马......）。

在物理上，**世界状态是作为数据库实现的**。这很有意义，因为数据库提供了丰富的运算符集，可以有效地存储和检索状态。稍后我们将看到`Hyperledger Fabric`可以配置为使用不同的世界状态数据库来满足不同类型的状态值和应用程序所需的访问模式的需求，例如在复杂查询中。

**事务捕获对世界状态的更改**，正如您所期望的，**事务具有生命周期**。它们由**应用程序创建**，**最终被提交到分类帐区块链**。[这里](https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html)详细描述了整个生命周期， 但`Hyperledger Fabric`的关键设计点是，只有由一组**认可组织** **签署**的交易才会导致对**世界状态的更新**。如果交易**未由足够**的背书节点**签署**，那么它将**无法通过**此有效性检查，并且**不会**导致对**世界状态的更新**。

还会注意到**状态具有版本号**，并且在上图中，状态`CAR1`和`CAR2`处于其起始版本`0`。每次**状态更改时，状态的版本号都会递增**。每当**状态更新**时也会**检查版本号**， **确保它与创建事务时的版本匹配**。此检查可确保世界状态**从相同的预期值更改为与**创建事务时**相同的预期值**。

最后，当**首次创建分类帐时，世界状态为空**。因为任何代表世界状态**有效变化的交易都记录在区块链**上，这意味着可以随时**从区块链<u>重新</u>生成世界状态**。这可能非常方便， 例如，在创建对等体时**自动生成**世界状态。此外，如果对等方**异常失败**，则可以在接受事务之前在对等**重启时重新生成**世界状态。

## 区块链

区块链是一个**事务日志**，结构为**互连块**，**每个块包含一系列事务**，**每个事务代表对世界状态的查询或更新**。在[其他地方](https://hyperledger-fabric.readthedocs.io/en/latest/peers/peers.html#peers-and-orderers)讨论了排序事务的确切机制，重要的是在块**首次创建**时建立**块排序**以及**块内的事务排序**。

每个块的**头部包括块的事务的散列**，以及**先前块的头部的散列的副本**。通过这种方式，分类账上的**所有交易都按顺序排列**并以加**密方式链接在一起**。这种**散列和链接使得分类帐数据非常安全**。即使托管分类帐的一个**节点被篡改**，它也**无法说服**所有其他节点它具有“**正确**”的区块链，**因为分类帐分布在整个独立节点的网络中**。

物理上，**区块链总是作为文件实现**，与使用**数据库的世界状态形成对比**。这是一种明智的设计选择，因为区块链数据结构严重偏向于一小组简单操作。**附加到区块链的末尾是主要操作**，查询当前是一个相对不频繁的操作。

让我们更详细地看一下区块链的结构。 

![ledger.blockchain](https://hyperledger-fabric.readthedocs.io/en/latest/_images/ledger.diagram.2.png)

事实表达的视觉词汇如下：区块链`B`包含块`B0，B1，B2，B3`。`B0`是区块链中的第一个区块，即**创世块**。

在上图中，我们可以看到**块** `B2`具有**块数据** `D2`，其包含其所有事务：`T5，T6，T7`。 

最重要的是，`B2`具有**块头** `H2`，其包含`D2`中所有事务的加密 **散列**以及来自前一块`B1`的等效散列。通过这种方式，块彼此之间有着不可分割和不可分割的联系，术语区块**链**如此巧妙地抓住前后的区块！

最后，正如在图中看到的，区块链中的**第一个块**称为**`genesis`块**。它是**分类帐的起点**，但它**不包含**任何用户事务。相反，它包含包含**网络通道的初始状态**（未示出）的配置事务。当我们在文档中讨论区块链网络和[通道](https://hyperledger-fabric.readthedocs.io/en/latest/channels.html)时，我们将更详细地讨论创世块。 

## 区块

一个块的结构，它由三部分组成：

+ **块头部 `Block Header`**

  此部分包含三个字段，在**创建块时写入**。

  - **`Block number` 区块编号**：一个从`0`开始的整数（**创世块**），并且对于附加到区块链的**每个新块**增加`1`。
  - **Current Block Hash 当前区块散列值**：当前块中包含的**所有事务**的哈希值。
  - **Previous Block Hash 前一个区块散列值**：区块链中前一个区块的哈希**副本**。

  ![ledger.blocks](https://hyperledger-fabric.readthedocs.io/en/latest/_images/ledger.diagram.4.png)

  事实表达的如下：块`B2`的块头`H2`由块号`2`，当前块数据`D2`的散列`CH2`和来自前一块（块号1）的散列`PH1`的副本组成。

+ **块数据 `Block Data`**

  本节包含**按顺序排列的交易清单**。它是在**创建块时写入**的。这些事务具有丰富但直接的结构，我们将在本主题[后面](https://hyperledger-fabric.readthedocs.io/en/latest/ledger/ledger.html#Transactions)介绍。

+ **块元数据 `Block Metadata`**

  此部分包含**写入块的时间**，以及块编写器的***证书、公钥和签名**。随后，块提交器还为每个事务添加了一个**有效/无效的指示符**，尽管此信息未包含在哈希中，因为创建块时会创建该信息。

## 交易





## 世界状态数据库选项



## 账本示例：`fabric`



## 其他




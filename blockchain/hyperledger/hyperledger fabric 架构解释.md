# `hyperledger fabric` 架构解释

`Hyperledger Fabric`架构具有以下优势：

+ **`Chaincode`信任灵活性**：该体系结构将**链代码(区块链应用程序)的信任**猜测与用于**排序的信任**猜测分开。换句话说，订购服务可以**由一组节点**(订购者)提供并且**容忍**它们中的一些**失败或行为不当**，并且对于每个链代码，参与者可以是不同的。
+ **可扩展性**：由于**负责特定链代码**的参与者节点与订货人正交，因此系统可能比这些功能由**相同节点完成**的情况**更好地扩展**。特别是，当**不同的链代码指定不相交的参与者**时，会产生这种情况，这会在参与者之间**引入链代码的分区**，并允许**并行链代码执行(认可)**。此外，从订购服务的关键路径中**移除可能成本高昂的链码执行**。
+ **保密**：该体系结构有助于部署对其**事务的内容和状态**更新具有**机密性要求**的链代码。
+ **共识模块化**：该架构是**模块化的**，并且允许**可插入的共识**(即订购服务)实现。



# 系统架构

区块链是一个**分布式系统**，由许多**相互通信的节点组成**。区块链**运行的程序**称为**链码**，**保存状态和分类帐数据**，并**执行事务**。链代码是**核心**元素，因为**事务是在链代码上调用的操作**。交易**必须“得到认可”**，并且只有经过认可的交易可能会**被承诺**并对国家产生影响。可能**存在用于管理功能和参数**的一个或多个特殊链代码，统称为**系统链代码**。

## 交易

交易可以有两种类型：

+ **部署事务**创建**新的链代码**并将程序**作为参数**。**成功执行部署事务**时，链代码已**安装在区块链**上。
+ **调用事务**在**先前部署**的链代码的**上下文中执行操作**。**调用事务**是指链代码及其提供的函数之一。成功时，链代码**执行指定的函数**，可能涉及**修改相应的状态**，并返回输出。

如稍后所述，**部署事务是调用事务的特殊情况**，其中创建新链代码的部署事务对应于系统链代码上的调用事务。

> 备注：本文档目前假定事务要么创建新的链代码，要么调用**已经部署的链代码**提供的操作。本文档尚未描述：a)查询(只读)事务的优化(包含在`v1`中)，b)支持**交叉链代码事务**(`v1`后功能)。

## 区块链数据结构

### 1、`State` 状态

区块链的最新状态(或简称为**状态**)被建模为**版本化键值存储**(`KVS`)，其中**键是名称**，**值是任意`blob`**。这些**状态条目**由区块链上运行的**链码(应用程序)通过`put`和`get` `KVS`操作来操纵**。持久存储状态并记录对状态的更新。请注意，**采用版本化的`KVS`作为状态模型**，实现可以使用实际的`KVS`，但也可以使用`RDBMS`或任何其他解决方案。

更正式地说，状态`s`被建模为映射`K ->(V X N)`的元素，其中：

+ `K`是一组键
+ `V`是一组值
+ `N`是**无限有序的版本号**集合。内射函数`next：N -> N`取`N`的元素并返回**下一个版本号**。

`V`和`N`都包含一个特殊元素`⊥`(**空类型**)，在`N`的情况下是**最低元素**。**最初所有键都映射到(`⊥，⊥`)**。对于`s(k)=(v,ver)`，用`s(k).value`表示`v`，用`s(k).version`表示`ver`。

`KVS`操作建模如下：

+ 把`(k，v)`用于`k∈K`和`v∈V`，取区块链状态`s`并将其改为`s'`，使`s'(k)=(v,next(s(k).version))`用`s'`对于所有`k'！= k，(k')= s(k')`。
+ `get(k)`返回`s(k)`。

`State`由**同行节点维护**，但不是由`Orderer`和客户端维护。

**状态分区**：`KVS`中的键可以**从其名称**中**识别**为属于特定的**链代码**，在某种意义上，**只有某个链代码的事务可以修改属于该链代码的键**。原则上，**任何**链代码都可以**读取**属于**其他链代码的键**。**支持跨链代码事务**，修改属于两个或多个链代码的状态是后`v1`功能。

### 2、`Ledger` 账本

`Ledger`提供了在系统运行期间发生的**所有成功状态更改(有效事务)和不成功尝试更改状态(无效事务)的可验证历史记录**。

`Ledger`**由订购服务构建**(参见第1.3.3节)，作为(有效或无效)交易块的完全**有序的哈希链**。`hashchain`强制分类帐中块的**总顺序**，**每个块包含一组完全有序的事务**。这会对所有交易**强加总订单**。

`Ledger`保留在**所有同行**，并且**可选地**保留在`orderers`的**子集中**。在`orderer`的上下文中，将`Ledger`称为`OrdererLedger`，而在对等的上下文中，将分类帐称为`PeerLedger`。`PeerLedger`与`OrdererLedger`的不同之处在于，**对等体在本地维护一个位掩码**，该位掩码将**有效事务与无效事务分开**。

对等方可以修剪`PeerLedger`。`Orderers`维护`OrdererLedger`的容错性和可用性(`PeerLedger`)，并且可以决定在任何时候修剪它，前提是维护订购服务的属性(参见第`1.3.3`节)。

**分类帐允许对等方重播所有事务的历史记录并重建状态**。因此，第`1.2.1`节中描述的状态是可选的数据结构。

### 3、`Nodes` 节点

**节点是区块链的通信实体**。**节点**在某种意义上只是一个**逻辑功能**，即**不同类型的多个节点可以在同一物理服务器上运行**。重要的是节点如何在“**信任域**”中**分组并与控制它们的逻辑实体相关联**。

有三种类型的节点：

+ **客户端或提交客户端**：向参与者**提交实际交易**调用的客户端，并将**交易提议广播到订购服务**。
+ **对等节点**：**提交事务并维护状态的节点和分类帐的副本**。此外，同行可以**拥有特殊**的参与者角色。
+ **定序服务节点或定序者**：运行**通信服务**的节点，实现**交付保证**，例如原子订单或总订单广播。

接下来更详细地解释节点的类型。

#### `Client` 客户端节点

---

**客户端代表最终用户的实体**。它**必须连接到对等体**与区块链通信。客户端可以连接到其**选择的任何对等方**。客户端**创建并从而调用事务**。

如第2节所述，**客户端与对等方和订购服务进行通信**。

#### `Peer` 对等节点

---

对等体从**订购服务接收块形式的有序状态更新**，并**维护状态和分类帐**。

同行还可以扮演**认可节点或背书人的特殊角色**。**签名对等体**的特殊功能针对**特定的链代码**发生，并且包括在提交事务之前支持该事务。每个链代码可以指定**引用一组支持对等方的认可策略**。该策略定义了**有效交易认可的必要和充分条件**(通常是一组代言人的签名)，如后面第2节和第3节所述。在安装新链码的部署交易的特殊情况下，(部署)**认可策略是指定为系统链码的认可策略**。

#### `Orderers` 定序服务节点

---

**订购者形成订购服务**，即提供**递送**保证的通信结构。订购服务可以以不同的方式实现：从**集中式服务**(例如，在开发和测试中使用)到针对**不同网络和节点故障模型**的**分布式协议**。

订购服务为**客户端和对等端**提供**共享通信**通道，为包含**事务的消息**提供**广播服务**。客户端连接到**信道**并且可以在**信道上广播消息**，然后将**消息传递给所有对等体**。该通道支持**所有消息的原子传递**，即具有**总订单传递**和(特定于实现)**可靠性的消息通信**。换句话说，**信道向所有连接的对等体输出相同的消息**，并以**相同的逻辑顺序**将它们输出到**所有对等体**。这种**原子通信**保证在**分布式系统的上下文中**也称为**全序广播**，**原子广播或共识**。传递的消息是包含在区块链**状态中的候选交易**。

**分区(订购服务渠道)**：订购服务可以支持类似于**发布/订阅**消息传送系统的**主题的多个频道**。客户端可以连接到**给定的通道**，然后可以**发送消息**并**获取到达的消息**。可以将**通道视为分区**，连接到一个**通道的客户端不知道其他通道的存在**，但客户端可能**连接到多个通道**。尽管`Hyperledger Fabric`中包含的某些订购服务实现**支持多个渠道**，但为了简化演示，在本文档的其余部分中，假设订购服务由**单个渠道/主题**组成。

**订购服务API**：对等方通过**订购服务**提供的接口连接到订购服务提供的**渠道**。订购服务`API`包含两个基本操作(更常见的是异步事件)：

添加`API`的一部分，用于在**客户端/对等**指定的**序列号**下获取特定块。

+ `broadcast(blob)` **广播**：客户端调用此方法来**广播任意消息`blob`**，以便通过该**频道进行传播**。当向服务发送请求时，这在`BFT`**上下文**中也称为`request(blob)`。
+ `deliver(seqno, prevhash, blob)` **交付**：订购服务在**对等体**上调用它以传递具有指定的**非负整数序列号(`seqno`)**和**最近交付的blob(`prevhash`)**的**散列的消息`blob`**。换句话说，它是来自订购服务的**输出事件**。`deliver()`有时**在`pub-sub`系统中称为`notify()`，在`BFT`系统中称为`commit()`**。

**分类帐和块形成**：分类帐包含订购服务**输出的所有数据**。简而言之，它是一系列传递`(seqno，prevhash，blob)`事件，根据**前面描述的`prevhash`的计算形成哈希链**。

大多数情况下，出于**效率原因**，订购服务**不输出单个事务(`blob`)**，而是在**单个传递事件中对`blob`和输出块进行分组(批处理)**。在这种情况下，**订购服务必须强制**并传达每个块内`blob`的**确定性排序**。可以通过**订购服务**实现来**动态地选择块中的`blob`的数量**。

在下文中，为了便于呈现，定义了订购服务属性并解释了事务认可的工作流程，假设每个交付事件有一个`blob`。根据上面提到的块内`blob`的**确定性排序**，假设块的传递事件对应于块内**每个`blob`的一系列单独传递事件，这些很容易扩展到块**。

**订购服务属性**

---

订购服务(或**原子广播频道**)的保证规定了**广播消息发生了什么**以及**所传递的消息之间存在什么关系**。这些保证如下：

1. **安全(一致性保证)**：只要对等体**连接到通道足够长的时间**(它们**可以断开连接或崩溃**，但将**重新启动并重新连接**)，它们将看到**相同系列的传递(`seqno，prevhash，blob`)消息**。这意味着输出`deliver()`事件在**所有对等体上**以**相同的顺序**发生，**根据序列号**并且**对于相同的序列号携带相同的内容(`blob`和`prevhash`)**。请注意，这只是一个**逻辑顺序**，并且**在一个对等体上的传递**(`seqno，prevhash，blob`)不需要在任何**实时**关系中发生(`seqno，prevhash，blob`)，它**在另一个对等体上输出相同的消息**。换句话说，**给定一个特定的`seqno`，没有两个正确的对等体提供不同的`prevhash`或`blob`值**。此外，除非某个客户端(对等方)实际调用`broadcast(blob)` ，并且**最好每个广播的`blob`仅传送一次**，否则不会传递值`blob`。

   此外，`deliver()`事件包含**先前`deliver()`事件**(`prevhash`)中数据的**加密哈希**。当订购服务实现原子**广播保证时**，`prevhash`是来自`deliver()`事件的**参数的加密哈希**，序列号为`seqno-1`。这将在`deliver()`事件之间**建立一个哈希链**，用于帮助**验证订购服务输出的完整性**，如第`4`节和第`5`节中所述。在**第一个`deliver()`事件的特殊情况下，`prevhash`具有默认值**。

2. **活跃度(传输保证)**：订购服务的实时保证由**订购服务**指定履行。确切的保证可能取决于**网络和节点故障模型**。

   原则上，如果**提交客户端没有失败**，则订购服务应该**保证连接到订购服务**的每个正确的**对等方最终提供每个提交的交易**。

**总而言之，订购服务可确保以下属性**：

+ **协议**：对于正确的同行的任何两个事件`deliver(seqno, prevhash0, blob0)`和`deliver(seqno, prevhash1, blob1)` 具有相同的`seqno`，`prevhash0 == prevhash1`和`blob0 == blob1`。
+ **`Hashchain`可信**：对于正确同行的任何两个事件`deliver(seqno-1, prevhash0, blob0)`和`deliver(seqno, prevhash, blob)`, `prevhash = HASH(seqno-1||prevhash0||blob0)`。
+ **没有跳过**：如果订购服务输出`deliver(seqno, prevhash, blob)` 在一个正确的同行`p`，这样的`seqno>0`，然后`p`已经发布了一个事件`deliver(seqno-1, prevhash0, blob0)`。
+ **没有创造**：任何事件`deliver(seqno, prevhash, blob)` 在一个正确的对等体之前，必须在一些(可能是不同的)对等体上进行`broadcast(blob)`事件。
+ **没有重复(可选，但可取)**：对于任何两个事件`broadcast(blob)`和`broadcast(blob')`，当两个事件`deliver(seqno0, prevhash0, blob)`和`deliver(seqno1, prevhash1, blob')` 发生在正确的同行和`blob == blob'`，然后`seqno0==seqno1` 和 `prevhash0==prevhash1`。
+ **活跃度**：如果正确的客户端调用事件`broadcast(blob)` ，然后每个正确的同伴**最终**发出一个事件`deliver(*, *, blob)`，其中`*`表示任意值。

# 交易认可的流程

> **注**：请注意，以下协议**并未假定所有交易都是确定性的，即它允许非确定性交易**。

下面将解释交易认可的基本工作流程：

+ 1、客户端创建一个事务并将其发送给自己选择的支持对等体
+ 2、认可对等体模拟交易并产生认可签名
+ 3、提交客户收集对交易的认可并通过订购服务进行广播
+ 4、订购服务向对等方提供交易



## 客户端创建一个事务并将其发送给自己选择的支持对等体

为了**调用事务**，**客户端**向其选择的**一组认可对等体**发送`PROPOSE`消息(**可能不同时**，参见`2.1.2`，和`2.3`节)。**给定`chaincodeID`的一组认可**对等体**通过对等体提供给客户端**，而对等体又从**认可策略**中了解支持对等体的集合(参见第3节)。例如，可以将事务发送给**给定`chaincodeID`的所有代言人**。也就是说，一些代言人可能会**脱机**，其他代言人可能会**反对并选择不支持交易**。**提交客户端**尝试使用**可用的代言人来满足策略表达式**。

在下文中，首先详细介绍`PROPOSE`消息格式，然后讨论提交客户端和代言人之间可能的**交互模式**。

### `PROPOSE`消息格式

`PROPOSE`消息的格式是`<PROPOSE，tx，[anchor]>`，其中`tx`是必需的，并且`anchor`可选参数在下面说明。

+ `tx=<clientID,chaincodeID,txPayload,timestamp,clientSig>`
  - `clientID` 是提交客户端的`ID`
  - `chaincodeID` 指交易所属的链码
  - `txPayload` 是包含提交的事务本身的有效负载
  - `timestamp` 是由客户端维护的单调递增(对于每个新事务)整数
  - `clientSig` 是`tx`其他领域的客户签名

`txPayload`的细节在**调用事务和部署事务**之间会有所不同(即，调用引用特定于**部署的系统链代码**的事务)。对于**调用事务，`txPayload`将包含两个字段**：

+ `txPayload = <operation, metadata>`
  - `operation` 表示**链代码操作(函数)和参数**
  - `metadata` 表示与**调用相关的属性**

对于部署事务，`txPayload`将包含三个字段：

+ `txPayload = <source, metadata, policies>`
  + `source` 表示链代码的源代码
  + `metadata` 表示与链代码和应用程序相关的属性
  + `policies` 包含与**所有**对等方**均可**访问的链代码相关的**策略**，例如认可策略。请注意，**部署事务中的`txPayload`不提供认可策略**，但部署的`txPayload`**包含认可策略`ID`及其参数**。

+ `anchor` 包含**读取版本依赖关系**，或者更具体地说，`key-version`对(即，`anchor`是`KxN`的子集)，**它将`PROPOSE`请求绑定或锚定到`KVS`中指定`key-version`**。如果客户端指定了`anchor`参数，则代言人仅在读取其**本地`KVS`匹配`anchor`相应键的版本号时才认可该事务**。

所有节点**使用`tx`的密码散列**作为唯一事务标识符`tid`(即`tid=HASH(tx)`)。客户端将`tid`存储在**内存中并等待来自同行的响应**。

### 消息模式

**客户端决定与代言人的互动顺序**。例如，客户端通常会将`<PROPOSE，tx>`(即没有`anchor`参数)**发送给单个代言人**，然后**生成版本依赖项**(`anchor`)，客户端稍后可以将其用作`PROPOSE`消息的**参数**发送给其他代言人。作为另一个例子，客户端可以直接向其选择的**所有代言人发送`<PROPOSE，tx>`**(无`anchor`)。不同的沟通模式是可能的，客户可以自由决定。

## 认可对等体模拟交易并产生认可签名

在从客户端接收到`<PROPOSE，tx，[anchor]>`消息时，支持对等`epID`**首先验证客户端的签名`clientSig`**，然后模拟事务。如果**客户端指定`anchor`**，那么**仅当读取的本地`KVS`中的相应`key-version`的版本**(即，如下定义的`readset`)匹配由`anchor`指定的那些版本号时，认可对等体才模拟事务。

**模拟事务**涉及通过调用事务引用的**链代码(`chaincodeID`)**以及**背书对等体本地保存的状态的副本**来支持对等体**暂时执行事务**(`txPayload`)。

作为执行的结果，认可对等体**计算读取版本依赖性(`readset`)和状态更新(`writeset`)**，在`DB`语言中也称为`MVCC + postimage`信息。

回想一下，**状态由键值对组成**。所有键值条目都是**版本化**的。也就是说，每个条目都**包含有序版本信息**，**每次更新存储**在键下的值时，该**版本信息都会递增**。解释事务的对等体记录链码访问的所有键值对，用于读取或写入，但**对等体尚未更新其状态**。进一步来说：

+ 在给予对等执行事务之前给定状态`s`，对于事务所读取的每个键`k`，将对`(k,s(k).version)`添加到`readset`。
+ 另外，对于由事务修改为新值`v'`的每个键`k`，将对`(k，v')`添加到`writeset`。或者`v'`可以是新值到先前值(`s(k).value`)的增量。

如果客户端在`PROPOSE`消息中**指定了`anchor` **，则**客户端指定的`anchor` 必须等于在模拟事务**时**通过支持对等方生成的`readset`**。

然后，对等体在**内部转发**(并且可能是`tx`)到**支持事务的(对等的)逻辑部分**，称为**支持逻辑**。默认情况下，对等体的**支持逻辑接受转发提议`tran-proposal`**并简单地**签署转移提议`tran-proposal`**。然而，支持逻辑可以解释任意功能，例如，通过`tran-proposal`和`tx`作为输入与遗留系统进行交互，以达成是否支持交易的决定。

如果支持逻辑决定支持一个事务，它就会发送 `<TRANSACTION-ENDORSED, tid, tran-proposal,epSig>`  消息提交客户端(`tx.clientID`)，其中：

+ `tran-proposal := (epID,tid,chaincodeID,txContentBlob,readset,writeset)`，其中`txContentBlob`是链码/事务特定信息。目的是将`txContentBlob`用作`tx`的某种表示(例如，`txContentBlob = tx.txPayload`)。
+ `epSig`是支持同行的签名`tran-proposal`

否则，如果支持逻辑**拒绝批准该交易**，则代言人可以**向提交客户端发送消息`(TRANSACTION-INVALID, tid, REJECTED)`**。

请注意，在此步骤中，**代言人不会更改其状态**，在代言的上下文中由事务**模拟生成的更新不会影响状态**！

## 提交客户收集对交易的认可并通过订购服务进行广播

提交客户端**等待**，直到它在`(TRANSACTION-ENDORSED, tid, *, *)`语句上收到“**足够**”的**消息和签名**，以**得出结束交易提议的背书**。这可能涉及**一次或多次**与代言人互动的**往返行程**。

“**足够**”的**确切数量**取决于**链码代言策略**(另见第3节)。**如果认可策略得到满足，则该交易已获得批准**。请注意，它**尚未提交**。来自支持同行的签名`TRANSACTION-ENDORSED`消息的集合(其确定交易被认可)被称为**认可并且由`endorsement`表示**。

如果提交客户端**无法收集对交易提案的认可**，**则会放弃此交易，并选择稍后重试**。

对于**有效认可**的交易，现在开始使用订购服务。提交客户端**使用`broadcast(blob)`调用**订购服务，其中`blob=endorsement`。如果客户端**没有直接调用**订购服务的能力，它可以通过其**选择的某个对等方代理**其广播。客户**必须信任这样的对等方**不要从认可中删除任何消息，否则该交易可能被**视为无效**。但请注意，**代理对等方可能无法制作有效的认可**。

## 订购服务向对等方提供交易

当**发生事件`deliver(seqno, prevhash, blob)` **并且对等方已为**序列号低于`seqno`的`blob`**，应用了**所有状态更新**时，对等方执行以下操作：

+ 它根据它所**引用的链码(`blob.tran-proposal.chaincodeID`)的策略检查`blob.endorsement`是否有效**。
+ 在典型的情况下，它还**验证同时没有违反依赖项**(`blob.endorsement.tran-proposal.readset`)。在更复杂的使用案例中，认可中的**提议提案字段可能不同**，在这种情况下，认可政策**规定了状态如何发展**。

根据为状态更新选择的**一致性**属性或“**隔离保证**”，可以以不同方式**实现依赖性**的验证。可**串行化**是**默认的隔离保证**，除非**链码认可策略指定不同的保证**。可以通过要求与`readset`中的**每个键相关联**的版本等于该状态中的该键的版本来提供可序列化，并**拒绝不满足此要求的事务**。

+ 如果**所有这些检查都通过**，则该交易被视为**有效或已提交**。在这种情况下，对等体在`PeerLedger`的位掩码中用**`1`标记事务**，将`blob.endorsement.tran-proposal.writeset`应用于区块链状态(如果`tran-proposal`相同，否则认可策略逻辑定义采用`blob.endorsement`的函数)。
+ 如果`blob.endorsement`的认可策略**验证失败**，则**事务无效**，并且对等体在`PeerLedger`的位掩码中**将事务标记为`0`**。请务必注意，**无效事务不会更改状态**。

请注意，在处理具有给定**序列号的传递事件(块)之后**，这足以使**所有(正确的)对等体具有相同的状态**。也就是说，通过**订购服务的保证**，所有正确的对等体将**接收相同**的序列`deliver(seqno, prevhash, blob)`事件。由于对**认可策略**的评估和对**`readset`中版本依赖性**的评估是确定性的，所以**所有正确的对等体**也将**得出相同的结论**，即`blob`中包含的事务**是否有效**。因此，所有对等体都以**相同的方式提交**并**应用相同的事务序列**并更新其状态。

![Illustration of the transaction flow (common-case path).](https://hyperledger-fabric.readthedocs.io/en/latest/_images/flow-4.png)

# 认可策略

## 认可策略的规范

**认可政策是支持交易的条件**。区块链对等体具有**预先指定的一组认可策略**，这些策略**由安装特定链代码的`deploy` 事务引用**。可以对认可策略**进行参数化**，并且可以通过`deploy`事务**指定这些参数**。

为了**保证区块链和安全属性**，一组认可策略应该是一组**经过验证的策略**，其功能**确保有限的执行时间**(终止)，**确定性，性能和安全保证**。

**动态添加认可策略**(例如，通过链代码部署时的**部署事务**)在有限策略评估时间(终止)，确定性，性能和安全保证方面**非常敏感**。因此，**不允许动态添加认可政策，但将来可以支持**。

## 针对认可政策的交易评估

只有在**根据策略批准**了事务时，才会**声明事务有效**。链代码的调用事务首先**必须获得满足链代码策略的认可**，否则它将**不会被提交**。这通过**提交客户端和支持同行节点**之间的**交互**来实现。

正式的认可政策是**对认可的预测**，并可能**进一步说明评估为真或假**。对于**部署事务**，根据**系统范围**的策略(例如，从系统链代码)**获得认可**。

认可政策是指某些变量，它可能指的是：

+ 与链代码相关的**密钥或身份**(在链代码的元数据中找到)，例如，一组代言人
+ 链码的其他**元数据**
+ `endorsement`和`endorsement.tran-proposal`的要素

上面的列表是通过**增加表达性和复杂性**来**排序**的，也就是说，支持仅引用节点的**密钥和标识**的策略将相对简单。

对认可政策断言的评估**必须是确定性的**。每个对等体都**应在本地评估认可**，使得对等体**不需要与其他对等体交互**，但所有**正确的对等体都以相同的方式评估认可策略**。

## 认可策略示例

断言可能包含**逻辑表达式**，并且计算结果为`TRUE`或`FALSE`。通常情况下，条件将在通过为链代码签署对等方发出的事务调用上**使用数字签名**。

假设链码指定了代言人集合`E = {Alice, Bob, Charlie, Dave, Eve, Frank, George}`。一些示例政策：

+ 来自`E`**所有成员**的**同一转发**提案上的**有效签名**
+ 来自`E`的**任何一个成员**的**有效**签名。
+ 根据条件批准**同一转发提案**的**有效**签名`(Alice OR Bob) AND (any two of: Charlie, Dave, Eve, Frank, George)`
+ `7`名代言人中的**任何`5`名**对**同一转发**提案的**有效**签名(一般地说，对于具有`n > 3f`代言人的链代码，`n`代言人中的任何`2f + 1`或任何超过`(n + f)/ 2`代言人的有效签名)
+ 假设向代言人分配了**“赌注”或“权重”**，例如`{Alice=49, Bob=15, Charlie=15, Dave=10, Eve=7, Frank=3, George=1}`，其中总赌注为`100`：该政策要求**拥有大部分赌注的集合中的有效签名**(即，合并赌注严重**超过50的**集团)，例如`{Alice，X}`，其中任何`X`与`George`不同，或`{everyone together except Alice}`等等。
+ 前一示例条件中的**桩的分配可以是静态**的(在链码的**元数据中固定**)或**动态**的(例如，取决于链码的**状态**并且在**执行期间被修改**)。
+ 来自`(Alice OR Bob)`对`tran-proposal1`的有效签名以及来自`(any two of: Charlie, Dave, Eve, Frank, George)`的有效签名关于`tran-proposal2`，其中`tran-proposal1`和`tran-proposal2`**仅在其支持同行中有所不同和状态更新**。

这些策略的有用性**取决于应用程序**，解决方案对于代言人的**失败或不良行为**以及各种其他属性所需的弹性。

# 验证分类帐和`PeerLedger`检查点(修剪)

## 验证分类帐(`VLedger`)

为了维护仅包含**有效**和**已提交**事务(例如，在比特币中出现)的分类帐的抽象化，除了状态和分类帐之外，**对等体可以维护验证分类帐(或`VLedger`)**。这是通过**过滤掉无效事务**从分类帐**派生的哈希链**。

`VLedger`块的构造(这里称为`vBlocks`)如下进行。由于`PeerLedger`块**可能包含无效事务**(即，具有**无效认可**或具有**无效版本依赖性**的事务)，因此在来自块的事务被添加到`vBlock`之前，这些事务**被对等体过滤掉**。每个对等体**自己完成此操作**(例如，通过使用与`PeerLedger`关联的位掩码)。`vBlock`被定义为**没有无效事务**的块，**已被过滤掉**。这样的`vBlock`本身具有**动态的大小并且可以是空的**。`vBlock`结构的图示如下图所示。

![Illustration of vBlock formation](https://hyperledger-fabric.readthedocs.io/en/latest/_images/blocks-3.png)

*图： 从分类帐(`PeerLedger`)块形成验证的分类帐块(`vBlock`)的图示*

每个对等体将`vBlock`链接到一个哈希链。更具体地说，**验证分类帐的每个块**包含：

+ **前一个**`vBlock`的**哈希值**
+ `vBlock`**编号**
+ 自计算**上一个`vBlock`以来由对等方提交的所有有效事务的有序列表**(即相应块中的**有效事务**列表)
+ 从中导出**当前`vBlock`的相应块**(在`PeerLedger`中)的散列

所有这些信息**由对等体连接和散列**，在经过**验证的分类帐中**生成`vBlock`的散列。

## `PeerLedger`检查点

**分类帐包含无效的交易**，可能**不一定永久**记录。但是，对等体**不能简单地丢弃`PeerLedger`块**，从而在建立相应的`vBlock`后**修剪**`PeerLedger`。即，在这种情况下，如果**新对等体加入网络**，则其他对等体**不能将丢弃的块（属于`PeerLedger`）转移到加入对等体**，也**不能使加入对等体相信其`vBlock`的有效性**。

为了便于修剪`PeerLedger`，本文档描述了一种检查点机制。此机制确定了跨对等网络的`vBlock`的有效性，并允许检查点的`vBlock`替换丢弃的`PeerLedger`块。这反过来减少了存储空间，因为不需要存储无效的事务。它还减少了为加入网络的新对等体重建状态的工作（因为它们在通过重放`PeerLedger`重建状态时不需要建立单个事务的有效性，但可以简单地重放验证的分类账中包含的状态更新）。


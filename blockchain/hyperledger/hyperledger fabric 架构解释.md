# `hyperledger fabric` 架构解释

`Hyperledger Fabric`架构具有以下优势：

+ **`Chaincode`信任灵活性**：该体系结构将**链代码（区块链应用程序）的信任**猜测与用于**排序的信任**猜测分开。换句话说，订购服务可以**由一组节点**（订购者）提供并且**容忍**它们中的一些**失败或行为不当**，并且对于每个链代码，参与者可以是不同的。
+ **可扩展性**：由于**负责特定链代码**的参与者节点与订货人正交，因此系统可能比这些功能由**相同节点完成**的情况**更好地扩展**。特别是，当**不同的链代码指定不相交的参与者**时，会产生这种情况，这会在参与者之间**引入链代码的分区**，并允许**并行链代码执行（认可）**。此外，从订购服务的关键路径中**移除可能成本高昂的链码执行**。
+ **保密**：该体系结构有助于部署对其**事务的内容和状态**更新具有**机密性要求**的链代码。
+ **共识模块化**：该架构是**模块化的**，并且允许**可插入的共识**（即订购服务）实现。



# 系统架构

区块链是一个**分布式系统**，由许多**相互通信的节点组成**。区块链**运行的程序**称为**链码**，**保存状态和分类帐数据**，并**执行事务**。链代码是**核心**元素，因为**事务是在链代码上调用的操作**。交易**必须“得到认可”**，并且只有经过认可的交易可能会**被承诺**并对国家产生影响。可能**存在用于管理功能和参数**的一个或多个特殊链代码，统称为**系统链代码**。

## 交易

交易可以有两种类型：

+ **部署事务**创建**新的链代码**并将程序**作为参数**。**成功执行部署事务**时，链代码已**安装在区块链**上。
+ **调用事务**在**先前部署**的链代码的**上下文中执行操作**。**调用事务**是指链代码及其提供的函数之一。成功时，链代码**执行指定的函数**，可能涉及**修改相应的状态**，并返回输出。

如稍后所述，**部署事务是调用事务的特殊情况**，其中创建新链代码的部署事务对应于系统链代码上的调用事务。

> 备注：本文档目前假定事务要么创建新的链代码，要么调用**已经部署的链代码**提供的操作。本文档尚未描述：a）查询（只读）事务的优化（包含在`v1`中），b）支持**交叉链代码事务**（`v1`后功能）。

## 区块链数据结构

### 1、`State` 状态

区块链的最新状态（或简称为**状态**）被建模为**版本化键值存储**（`KVS`），其中**键是名称**，**值是任意`blob`**。这些**状态条目**由区块链上运行的**链码（应用程序）通过`put`和`get` `KVS`操作来操纵**。持久存储状态并记录对状态的更新。请注意，**采用版本化的`KVS`作为状态模型**，实现可以使用实际的`KVS`，但也可以使用`RDBMS`或任何其他解决方案。

更正式地说，状态`s`被建模为映射`K ->（V X N）`的元素，其中：

+ `K`是一组键
+ `V`是一组值
+ `N`是**无限有序的版本号**集合。内射函数`next：N -> N`取`N`的元素并返回**下一个版本号**。

`V`和`N`都包含一个特殊元素`⊥`（**空类型**），在`N`的情况下是**最低元素**。**最初所有键都映射到（`⊥，⊥`）**。对于`s(k)=(v,ver)`，用`s(k).value`表示`v`，用`s(k).version`表示`ver`。

`KVS`操作建模如下：

+ 把`（k，v）`用于`k∈K`和`v∈V`，取区块链状态`s`并将其改为`s'`，使`s'(k)=(v,next(s(k).version))`用`s'`对于所有`k'！= k，（k'）= s（k'）`。
+ `get(k)`返回`s(k)`。

`State`由**同行节点维护**，但不是由`Orderer`和客户端维护。

**状态分区**：`KVS`中的键可以**从其名称**中**识别**为属于特定的**链代码**，在某种意义上，**只有某个链代码的事务可以修改属于该链代码的键**。原则上，**任何**链代码都可以**读取**属于**其他链代码的键**。**支持跨链代码事务**，修改属于两个或多个链代码的状态是后`v1`功能。

### 2、`Ledger` 账本

`Ledger`提供了在系统运行期间发生的**所有成功状态更改（有效事务）和不成功尝试更改状态（无效事务）的可验证历史记录**。

`Ledger`**由订购服务构建**（参见第1.3.3节），作为（有效或无效）交易块的完全**有序的哈希链**。`hashchain`强制分类帐中块的**总顺序**，**每个块包含一组完全有序的事务**。这会对所有交易**强加总订单**。

`Ledger`保留在**所有同行**，并且**可选地**保留在`orderers`的**子集中**。在`orderer`的上下文中，将`Ledger`称为`OrdererLedger`，而在对等的上下文中，将分类帐称为`PeerLedger`。`PeerLedger`与`OrdererLedger`的不同之处在于，**对等体在本地维护一个位掩码**，该位掩码将**有效事务与无效事务分开**。

对等方可以修剪`PeerLedger`。`Orderers`维护`OrdererLedger`的容错性和可用性（`PeerLedger`），并且可以决定在任何时候修剪它，前提是维护订购服务的属性（参见第`1.3.3`节）。

**分类帐允许对等方重播所有事务的历史记录并重建状态**。因此，第`1.2.1`节中描述的状态是可选的数据结构。

### 3、`Nodes` 节点

**节点是区块链的通信实体**。**节点**在某种意义上只是一个**逻辑功能**，即**不同类型的多个节点可以在同一物理服务器上运行**。重要的是节点如何在“**信任域**”中**分组并与控制它们的逻辑实体相关联**。

有三种类型的节点：

+ **客户端或提交客户端**：向参与者**提交实际交易**调用的客户端，并将**交易提议广播到订购服务**。
+ **对等节点**：**提交事务并维护状态的节点和分类帐的副本**。此外，同行可以**拥有特殊**的参与者角色。
+ **定序服务节点或定序者**：运行**通信服务**的节点，实现**交付保证**，例如原子订单或总订单广播。

接下来更详细地解释节点的类型。

#### `Client` 客户端节点

---

**客户端代表最终用户的实体**。它**必须连接到对等体**与区块链通信。客户端可以连接到其**选择的任何对等方**。客户端**创建并从而调用事务**。

如第2节所述，**客户端与对等方和订购服务进行通信**。

#### `Peer` 对等节点

---

对等体从**订购服务接收块形式的有序状态更新**，并**维护状态和分类帐**。

同行还可以扮演**认可节点或背书人的特殊角色**。**签名对等体**的特殊功能针对**特定的链代码**发生，并且包括在提交事务之前支持该事务。每个链代码可以指定**引用一组支持对等方的认可策略**。该策略定义了**有效交易认可的必要和充分条件**（通常是一组代言人的签名），如后面第2节和第3节所述。在安装新链码的部署交易的特殊情况下，（部署）**认可政策是指定为系统链码的认可政策**。

#### `Orderers` 定序服务节点

---

**订购者形成订购服务**，即提供**递送**保证的通信结构。订购服务可以以不同的方式实现：从**集中式服务**（例如，在开发和测试中使用）到针对**不同网络和节点故障模型**的**分布式协议**。

订购服务为**客户端和对等端**提供**共享通信**通道，为包含**事务的消息**提供**广播服务**。客户端连接到**信道**并且可以在**信道上广播消息**，然后将**消息传递给所有对等体**。该通道支持**所有消息的原子传递**，即具有**总订单传递**和（特定于实现）**可靠性的消息通信**。换句话说，**信道向所有连接的对等体输出相同的消息**，并以**相同的逻辑顺序**将它们输出到**所有对等体**。这种**原子通信**保证在**分布式系统的上下文中**也称为**全序广播**，**原子广播或共识**。传递的消息是包含在区块链**状态中的候选交易**。

**分区（订购服务渠道）**：订购服务可以支持类似于**发布/订阅**消息传送系统的**主题的多个频道**。客户端可以连接到**给定的通道**，然后可以**发送消息**并**获取到达的消息**。可以将**通道视为分区**，连接到一个**通道的客户端不知道其他通道的存在**，但客户端可能**连接到多个通道**。尽管`Hyperledger Fabric`中包含的某些订购服务实现**支持多个渠道**，但为了简化演示，在本文档的其余部分中，假设订购服务由**单个渠道/主题**组成。

**订购服务API**：对等方通过**订购服务**提供的接口连接到订购服务提供的**渠道**。订购服务`API`包含两个基本操作（更常见的是异步事件）：

添加`API`的一部分，用于在**客户端/对等**指定的**序列号**下获取特定块。

+ `broadcast(blob)` **广播**：客户端调用此方法来**广播任意消息`blob`**，以便通过该**频道进行传播**。当向服务发送请求时，这在`BFT`**上下文**中也称为`request(blob)`。
+ `deliver(seqno, prevhash, blob)` **交付**：订购服务在**对等体**上调用它以传递具有指定的**非负整数序列号（`seqno`）**和**最近交付的blob（`prevhash`）**的**散列的消息`blob`**。换句话说，它是来自订购服务的**输出事件**。`deliver()`有时**在`pub-sub`系统中称为`notify()`，在`BFT`系统中称为`commit()`**。

**分类帐和块形成**：分类帐包含订购服务**输出的所有数据**。简而言之，它是一系列传递`（seqno，prevhash，blob）`事件，根据**前面描述的`prevhash`的计算形成哈希链**。

大多数情况下，出于**效率原因**，订购服务**不输出单个事务（`blob`）**，而是在**单个传递事件中对`blob`和输出块进行分组（批处理）**。在这种情况下，**订购服务必须强制**并传达每个块内`blob`的**确定性排序**。可以通过**订购服务**实现来**动态地选择块中的`blob`的数量**。

在下文中，为了便于呈现，定义了订购服务属性并解释了事务认可的工作流程，假设每个交付事件有一个`blob`。根据上面提到的块内`blob`的**确定性排序**，假设块的传递事件对应于块内**每个`blob`的一系列单独传递事件，这些很容易扩展到块**。

**订购服务属性**

---

订购服务（或**原子广播频道**）的保证规定了**广播消息发生了什么**以及**所传递的消息之间存在什么关系**。这些保证如下：

1. **安全（一致性保证）**：只要对等体**连接到通道足够长的时间**（它们**可以断开连接或崩溃**，但将**重新启动并重新连接**），它们将看到**相同系列的传递（`seqno，prevhash，blob`）消息**。这意味着输出`deliver()`事件在**所有对等体上**以**相同的顺序**发生，**根据序列号**并且**对于相同的序列号携带相同的内容（`blob`和`prevhash`）**。请注意，这只是一个**逻辑顺序**，并且**在一个对等体上的传递**（`seqno，prevhash，blob`）不需要在任何**实时**关系中发生（`seqno，prevhash，blob`），它**在另一个对等体上输出相同的消息**。换句话说，**给定一个特定的`seqno`，没有两个正确的对等体提供不同的`prevhash`或`blob`值**。此外，除非某个客户端（对等方）实际调用`broadcast(blob)` ，并且**最好每个广播的`blob`仅传送一次**，否则不会传递值`blob`。

   此外，`deliver()`事件包含**先前`deliver()`事件**（`prevhash`）中数据的**加密哈希**。当订购服务实现原子**广播保证时**，`prevhash`是来自`deliver()`事件的**参数的加密哈希**，序列号为`seqno-1`。这将在`deliver()`事件之间**建立一个哈希链**，用于帮助**验证订购服务输出的完整性**，如第`4`节和第`5`节中所述。在**第一个`deliver()`事件的特殊情况下，`prevhash`具有默认值**。

2. **活跃度（传输保证）**：订购服务的实时保证由**订购服务**指定履行。确切的保证可能取决于**网络和节点故障模型**。

   原则上，如果**提交客户端没有失败**，则订购服务应该**保证连接到订购服务**的每个正确的**对等方最终提供每个提交的交易**。

**总而言之，订购服务可确保以下属性**：

+ **协议**：对于正确的同行的任何两个事件`deliver(seqno, prevhash0, blob0)`和`deliver(seqno, prevhash1, blob1)` 具有相同的`seqno`，`prevhash0 == prevhash1`和`blob0 == blob1`。
+ **`Hashchain`可信**：对于正确同行的任何两个事件`deliver(seqno-1, prevhash0, blob0)`和`deliver(seqno, prevhash, blob)`, `prevhash = HASH(seqno-1||prevhash0||blob0)`。
+ **没有跳过**：如果订购服务输出`deliver(seqno, prevhash, blob)` 在一个正确的同行`p`，这样的`seqno>0`，然后`p`已经发布了一个事件`deliver(seqno-1, prevhash0, blob0)`。
+ **没有创造**：任何事件`deliver(seqno, prevhash, blob)` 在一个正确的对等体之前，必须在一些（可能是不同的）对等体上进行`broadcast(blob)`事件。
+ **没有重复（可选，但可取）**：对于任何两个事件`broadcast(blob)`和`broadcast(blob')`，当两个事件`deliver(seqno0, prevhash0, blob)`和`deliver(seqno1, prevhash1, blob')` 发生在正确的同行和`blob == blob'`，然后`seqno0==seqno1` 和 `prevhash0==prevhash1`。
+ **活跃度**：如果正确的客户端调用事件`broadcast(blob)` ，然后每个正确的同伴**最终**发出一个事件`deliver(*, *, blob)`，其中`*`表示任意值。

# 交易认可的基本工作流程

> **注**：请注意，以下协议**并未假定所有交易都是确定性的，即它允许非确定性交易**。

下面将解释交易认可的基本工作流程：

+ 1、客户端创建一个事务并将其发送给自己选择的支持对等体
+ 2、认可对等体模拟交易并产生认可签名
+ 3、提交客户收集对交易的认可并通过订购服务进行广播
+ 4、订购服务向对等方提供交易



## 客户端创建一个事务并将其发送给自己选择的支持对等体

为了**调用事务**，**客户端**向其选择的**一组认可对等体**发送`PROPOSE`消息（**可能不同时**，参见`2.1.2`，和`2.3`节）。**给定`chaincodeID`的一组认可**对等体**通过对等体提供给客户端**，而对等体又从**认可策略**中了解支持对等体的集合（参见第3节）。例如，可以将事务发送给**给定`chaincodeID`的所有代言人**。也就是说，一些代言人可能会**脱机**，其他代言人可能会**反对并选择不支持交易**。**提交客户端**尝试使用**可用的代言人来满足策略表达式**。

在下文中，首先详细介绍`PROPOSE`消息格式，然后讨论提交客户端和代言人之间可能的**交互模式**。

### `PROPOSE`消息格式

`PROPOSE`消息的格式是`<PROPOSE，tx，[anchor]>`，其中`tx`是必需的，并且`anchor`可选参数在下面说明。

+ `tx=<clientID,chaincodeID,txPayload,timestamp,clientSig>`
  - `clientID` 是提交客户端的`ID`
  - `chaincodeID` 指交易所属的链码
  - `txPayload` 是包含提交的事务本身的有效负载
  - `timestamp` 是由客户端维护的单调递增（对于每个新事务）整数
  - `clientSig` 是`tx`其他领域的客户签名

`txPayload`的细节在**调用事务和部署事务**之间会有所不同（即，调用引用特定于**部署的系统链代码**的事务）。对于**调用事务，`txPayload`将包含两个字段**：

+ `txPayload = <operation, metadata>`
  - `operation` 表示**链代码操作（函数）和参数**
  - `metadata` 表示与**调用相关的属性**

对于部署事务，`txPayload`将包含三个字段：

+ `txPayload = <source, metadata, policies>`
  + `source` 表示链代码的源代码
  + `metadata` 表示与链代码和应用程序相关的属性
  + `policies` 包含与**所有**对等方**均可**访问的链代码相关的**策略**，例如认可策略。请注意，**部署事务中的`txPayload`不提供认可策略**，但部署的`txPayload`**包含认可策略`ID`及其参数**。

+ `anchor` 包含**读取版本依赖关系**，或者更具体地说，`key-version`对（即，`anchor`是`KxN`的子集），**它将`PROPOSE`请求绑定或锚定到`KVS`中指定`key-version`**。如果客户端指定了`anchor`参数，则代言人仅在读取其**本地`KVS`匹配`anchor`相应键的版本号时才认可该事务**。

所有节点**使用`tx`的密码散列**作为唯一事务标识符`tid`（即`tid=HASH(tx)`）。客户端将`tid`存储在**内存中并等待来自同行的响应**。

### 消息模式

**客户端决定与代言人的互动顺序**。例如，客户端通常会将`<PROPOSE，tx>`（即没有`anchor`参数）**发送给单个代言人**，然后**生成版本依赖项**（`anchor`），客户端稍后可以将其用作`PROPOSE`消息的**参数**发送给其他代言人。作为另一个例子，客户端可以直接向其选择的**所有代言人发送`<PROPOSE，tx>`**（无`anchor`）。不同的沟通模式是可能的，客户可以自由决定。

## 认可对等体模拟交易并产生认可签名



## 提交客户收集对交易的认可并通过订购服务进行广播



## 订购服务向对等方提供交易


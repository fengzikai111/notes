# `hyperledger fabric` 架构解释

`Hyperledger Fabric`架构具有以下优势：

+ **`Chaincode`信任灵活性**：该体系结构将**链代码（区块链应用程序）的信任**猜测与用于**排序的信任**猜测分开。换句话说，订购服务可以**由一组节点**（订购者）提供并且**容忍**它们中的一些**失败或行为不当**，并且对于每个链代码，参与者可以是不同的。
+ **可扩展性**：由于**负责特定链代码**的参与者节点与订货人正交，因此系统可能比这些功能由**相同节点完成**的情况**更好地扩展**。特别是，当**不同的链代码指定不相交的参与者**时，会产生这种情况，这会在参与者之间**引入链代码的分区**，并允许**并行链代码执行（认可）**。此外，从订购服务的关键路径中**移除可能成本高昂的链码执行**。
+ **保密**：该体系结构有助于部署对其**事务的内容和状态**更新具有**机密性要求**的链代码。
+ **共识模块化**：该架构是**模块化的**，并且允许**可插入的共识**（即订购服务）实现。



# 系统架构

区块链是一个**分布式系统**，由许多**相互通信的节点组成**。区块链**运行的程序**称为**链码**，**保存状态和分类帐数据**，并**执行事务**。链代码是**核心**元素，因为**事务是在链代码上调用的操作**。交易**必须“得到认可”**，并且只有经过认可的交易可能会**被承诺**并对国家产生影响。可能**存在用于管理功能和参数**的一个或多个特殊链代码，统称为**系统链代码**。

## 交易

交易可以有两种类型：

+ **部署事务**创建**新的链代码**并将程序**作为参数**。**成功执行部署事务**时，链代码已**安装在区块链**上。
+ **调用事务**在**先前部署**的链代码的**上下文中执行操作**。**调用事务**是指链代码及其提供的函数之一。成功时，链代码**执行指定的函数**，可能涉及**修改相应的状态**，并返回输出。

如稍后所述，**部署事务是调用事务的特殊情况**，其中创建新链代码的部署事务对应于系统链代码上的调用事务。

> 备注：本文档目前假定事务要么创建新的链代码，要么调用**已经部署的链代码**提供的操作。本文档尚未描述：a）查询（只读）事务的优化（包含在`v1`中），b）支持**交叉链代码事务**（`v1`后功能）。

## 区块链数据结构

### 1、`State` 状态

区块链的最新状态（或简称为**状态**）被建模为**版本化键值存储**（`KVS`），其中**键是名称**，**值是任意`blob`**。这些**状态条目**由区块链上运行的**链码（应用程序）通过`put`和`get` `KVS`操作来操纵**。持久存储状态并记录对状态的更新。请注意，**采用版本化的`KVS`作为状态模型**，实现可以使用实际的`KVS`，但也可以使用`RDBMS`或任何其他解决方案。

更正式地说，状态`s`被建模为映射`K ->（V X N）`的元素，其中：

+ `K`是一组键
+ `V`是一组值
+ `N`是**无限有序的版本号**集合。内射函数`next：N -> N`取`N`的元素并返回**下一个版本号**。

`V`和`N`都包含一个特殊元素`⊥`（**空类型**），在`N`的情况下是**最低元素**。**最初所有键都映射到（`⊥，⊥`）**。对于`s(k)=(v,ver)`，用`s(k).value`表示`v`，用`s(k).version`表示`ver`。

`KVS`操作建模如下：

+ 把`（k，v）`用于`k∈K`和`v∈V`，取区块链状态`s`并将其改为`s'`，使`s'(k)=(v,next(s(k).version))`用`s'`对于所有`k'！= k，（k'）= s（k'）`。
+ `get(k)`返回`s(k)`。

`State`由**同行节点维护**，但不是由`Orderer`和客户端维护。

**状态分区**：`KVS`中的键可以**从其名称**中**识别**为属于特定的**链代码**，在某种意义上，**只有某个链代码的事务可以修改属于该链代码的键**。原则上，**任何**链代码都可以**读取**属于**其他链代码的键**。**支持跨链代码事务**，修改属于两个或多个链代码的状态是后`v1`功能。

### 2、`Ledger` 账本

`Ledger`提供了在系统运行期间发生的**所有成功状态更改（有效事务）和不成功尝试更改状态（无效事务）的可验证历史记录**。

`Ledger`**由订购服务构建**（参见第1.3.3节），作为（有效或无效）交易块的完全**有序的哈希链**。`hashchain`强制分类帐中块的**总顺序**，**每个块包含一组完全有序的事务**。这会对所有交易**强加总订单**。

`Ledger`保留在**所有同行**，并且**可选地**保留在`orderers`的**子集中**。在`orderer`的上下文中，将`Ledger`称为`OrdererLedger`，而在对等的上下文中，将分类帐称为`PeerLedger`。`PeerLedger`与`OrdererLedger`的不同之处在于，**对等体在本地维护一个位掩码**，该位掩码将**有效事务与无效事务分开**。

对等方可以修剪`PeerLedger`。`Orderers`维护`OrdererLedger`的容错性和可用性（`PeerLedger`），并且可以决定在任何时候修剪它，前提是维护订购服务的属性（参见第`1.3.3`节）。

**分类帐允许对等方重播所有事务的历史记录并重建状态**。因此，第`1.2.1`节中描述的状态是可选的数据结构。

### 3、`Nodes` 节点

#### `Client` 客户端节点

#### `Peer` 对等节点

#### `Orderers` 定序服务节点





